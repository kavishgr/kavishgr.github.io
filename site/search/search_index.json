{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notes to self Go back to my blog","title":"Home"},{"location":"#notes-to-self","text":"Go back to my blog","title":"Notes to self"},{"location":"bash_alias/","text":"Bash Alias Vim Sort by size alias vimsize='find . -type f -exec ls -l {} \\; | vim -' Then run: :%! sort -k5,5 -n Grep New version of grep: alias egrep='/usr/local/opt/grep/bin/gegrep' alias fgrep='/usr/local/opt/grep/bin/gfgrep' alias grep='/usr/local/opt/grep/bin/ggrep --color=always' Find dotdot slash: alias gdot='grep -Hrn \"\\.\\./\" * '","title":"Bash Alias"},{"location":"bash_alias/#bash-alias","text":"","title":"Bash Alias"},{"location":"bash_alias/#vim","text":"","title":"Vim"},{"location":"bash_alias/#sort-by-size","text":"alias vimsize='find . -type f -exec ls -l {} \\; | vim -' Then run: :%! sort -k5,5 -n","title":"Sort by size"},{"location":"bash_alias/#grep","text":"","title":"Grep"},{"location":"bash_alias/#new-version-of-grep","text":"alias egrep='/usr/local/opt/grep/bin/gegrep' alias fgrep='/usr/local/opt/grep/bin/gfgrep' alias grep='/usr/local/opt/grep/bin/ggrep --color=always'","title":"New version of grep:"},{"location":"bash_alias/#find-dotdot-slash","text":"alias gdot='grep -Hrn \"\\.\\./\" * '","title":"Find dotdot slash:"},{"location":"golang/","text":"Golang Pointers A Pointer is a variable that stores the memory address of another variable. A variable can contain any type of values, but when a variable has a memory address as its value, it's called a pointer. To create a pointer, an & operator is used to retrieve the memory address of a variable: var x = 101 // an integer as its value var ptr = &x // get the memory address of x and stores it in a variable called ptr The &x retrieves the memory address of x and stores it in ptr . A complete example: package main import \"fmt\" var p = fmt.Println func main() { var x = 101 var ptr = &x p(\"The memory address of x:\", &x) p(\"The memory address of ptr:\", &ptr) p(\"The value of ptr:\", ptr) } // output The memory address of x: 0xc0000b4020 The memory address of ptr: 0xc0000b6018 The value of ptr: 0xc0000b4020 Go Playground Every variable represents a memory address pointing to a value like so: 0xc0000b6018 = 101 A variable pointing to a memory address of another variable is called a pointer. Dereferencing a Pointer Dereferencing is used to access or manipulate data contained in a memory location pointed to by a pointer variable or simply pointer. To access or manipulate the data of a pointer or to dereference a pointer, an * operator is used in front of the pointer variable: package main import \"fmt\" var p = fmt.Println func main() { var x = \"Having fun with pointers\" // declare a varible with data of type string var ptr = &x // store the memory address of variable, hence a pointer p(*ptr) // print the value of the pointer *ptr = \"Still having fun with pointers\" // dereference the pointer with new data p(x) // print the new data } Go Playground A Pointer as an Argument in a Function To define a function() that takes a memory address as an argument or simply a pointer, *T is used as the type. In this case, *int which stands for a pointer to an int, or a memory address whose value is an int. You give the function() a memory address by prepending the variable with an & operator. Inside the function, an * is used to access the value, hence dereferencing a pointer. package main import ( \"fmt\" ) func zero(ptr *int){ // *int means: I need a memory address that points to data of type int // behind the scene, ptr will point to a memory address that looks like this (in hexadecimal): ptr = 0xc00002c008 // on the next line, the asterisk '*' is used again(now in front of the pointer variable) // to dereference the pointer, hence access/manipulate the value stored in that particular // memory address // behind the scene => replace the current value of 0xc00002c008 or ptr with 0 *ptr = 0 // store 0 in the memory address *ptr is refering to // if I write: ptr = 0 // the go compiler will return an error saying: cannot use 0 (type int) as type *int in assignment // because ptr is like: var ptr *int // ptr will only accept or store a memory address as its value // // you can't just assign a value in it // you have to dereference it first } func main() { x := 5 zero(&x) // the & operator finds the address of variable x fmt.Println(x) } Go Playground Assignment Operators Loops The beauty of Go's For loop is that it merges many modern style of looping into one keyword . Loops always begin with the for keyword. Init, Condition, and Post (optional) func main() { for i := 0; i <=3; i++{ fmt.Println(i) } } Initialize a statement - i := 0 Condition that determine if the loop has to continue or stop - i <= 3 Post statement runs if condition is true - i++ (including the loop block {}) The variable i is only visible in the loop block. While loop To construct a while loop , omit the init and post statement: package main import ( \"fmt\" ) func main() { i := 0 // declared outside of loop block fmt.Println(\"i is\", i) for i < 5{ // while true, keep looping i++ fmt.Println(\"Now i is\", i) } // end of loop block fmt.Println() fmt.Println(\"Final is\", i) } Infinite loop For...range loop Continue and Break Slice A slice is a dynamic container that hold elements of the same type. It's build on top of an array. https://play.golang.org/p/GJrrw1BYo_O Slice Literal A slice literal is used when you already know what values it will contain: package main import ( \"fmt\" ) func main() { s := []string{\"a\", \"b\", \"c\", \"d\"} fmt.Println(s) } Two ways to create an empty or nil slice Initialize an empty slice with a nil value: var mySlice []int According to Golang Wiki , the former is the preferred way. Using the builtin make function to create an empty slice (non-nil): mySlice := make([]string, 0, 10) The syntax: make([]T, length, capacity) Full example: package main import ( \"fmt\" ) func main() { mySlice := make([]int, 5, 10) fmt.Printf(\"mySlice is of type %T\\nIts length is %v\\nIts capacity is %v\", mySlice, len(mySlice), cap(mySlice)) } Output: mySlice is of type []int Its length is 5 Its capacity is 10 To create a slice with a length or capacity, use make() Go Playground There's another shortcut: slice := []string{} The above slice is empty with a length of zero instead of nil(non-nil slice). Note: In most cases, empty slice and nil slice can be treated the same. In some cases, they should be treated differently, one of them is when doing JSON encoding. An empty slice will be encoded as an [] in JSON while nil slice will be encoded as null . for...range loop over a slice The recommended way to iterate over a slice is by using a for...range loop: package main import ( \"fmt\" ) func main() { mySlice := []int{1, 2, 3, 4, 5} for i, v := range mySlice { fmt.Printf(\"Index %v has the value of %v\\n\", i, v) } } Go Playground Slicing a slice Slicing is used to access an individual or a slice of an array. Why a slice of an array? Because slices are built on top of arrays. If you change an array, the result will reflect in the slice. To use the slice operator, two indexes are required : where the slice should start, and where the slice should stop, but not including it. Slicing from index 0 to 4 : package main import \"fmt\" func main() { underlyingArray := [5]string{\"g\", \"o\", \"l\", \"a\", \"n\", \"g\"} slice := underlyingArray[0:4] fmt.Println(slice) } Output is: [g o l a] The second index is the index the slice will stop before. Slice from index 1 till the end package main import ( \"fmt\" \"os\" ) func main() { slice := os.Args[1:] for _, v := range slice { go doSomethingAmazing(v) } } Take a list of arguments from standard input and slice from index 1 till the end. Index 0 or the name of the Go script is discarded. Slice from index 0 till index 4 If you omit the start index, 0 will be used as default: package main import ( \"fmt\" \"os\" ) func main() { underlyingArray := [5]int{1, 2, 3, 4, 5} slice := os.Args[:3] for i, v := range slice { fmt.Printf(\"Index %v has the value of %v.\", i, v) } } Output is: [1 2 3] Appending to a slice The built-in append function , appends element to the end of a slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself. The anatomy of the append function : func append(slice []Type, elems ...Type) []Type It takes a slice as the first parameter, and the second parameter can be an unlimited number of elements of the same type or another slice(unfurled with an elipsis). And it returns a slice. That's why it's recommended to store the result in the slice that we're appending values to. Example: package main import ( \"fmt\" \"bufio\" \"os\" ) func main() { var slice []string // initialize a nil slice fmt.Println(slice) // slice is nil sc := bufio.NewScanner(os.Stdin) // take parameters from standard input for sc.Scan() { // loop over lines of input slice = append(slice, sc.Text()) // append each line to the slice } fmt.Println(slice) // results } Try it: echo -e \"1\\n2\\n3\\n4\" | go run main.go Passing Slices to a Variadic Function package main import ( \"fmt\" \"strings\" ) func main() { s := []string{\"Go\", \"is\", \"my\", \"favourite\", \"Programming\", \"Language\"} // creates a slice of string with 6 elements result := concatStrings(s...) // unfurl the slice with an elipsis and pass it to the function fmt.Println(result) // prints the result } func concatStrings(sentence ...string) string { var sum string for _, v := range sentence { sum += v + \" \" // concatenate all elements } sum = strings.TrimSpace(sum) // remove leading and trailing spaces return sum + \".\" // add a dot at the end } Go Playground The danger of appending to a slice that already has a length and a capacity package main import ( \"fmt\" ) func main() { numbers := []int{11, 12, 13} mySlice := make([]int, 5, 10) for _, v := range numbers{ mySlice = append(mySlice, v) } fmt.Println(mySlice) } Output: [0 0 0 0 0 11 12 13] One of the ways to make use of an empty slice: package main import ( \"fmt\" ) func main() { candidates := []string{\"macOS\", \"OpenBSD\", \"Linux\"} // number of votes votes := []string{\"macOS\", \"OpenBSD\", \"Linux\", \"macOS\", \"OpenBSD\", \"macOS\"} // make an empty slice with the length of the total number of candidates counts := make([]int, len(candidates)) for _, vote := range votes { matched := false for i, candidate := range candidates { if candidate == vote { counts[i]++ matched = true } } if matched == false { candidates = append(candidates, vote) counts = append(counts, 1) } } for i, candidate := range candidates { fmt.Printf(\"%s: %d\\n\", candidate, counts[i]) } } Go Playground Update entries in a loop num := []int{11, 12, 13} for _, n := range num { n += 1 } fmt.Println(s) // Output: [11 12 13] The thing is, all the values is being copied one by one to a local variable n ; the slice remained intact. That's why in certain situation, we have to use pointers. To update the slice, call the slice itself: num := []int{11, 12, 13} for i := range num { // n: value is not needed s[i] =+ 1 } fmt.Println(s) // Output: [12 13 14] remove duplicate values from a slice https://www.golangprograms.com/remove-duplicate-values-from-slice.html Maps A map is an unordered list of key-value pairs. It's a dynamic data structure. It can't contain dupicate keys. Create an empty map, and a map literal Empty map: Syntax : make(map[KeyType]ValueType) m := make(map[string]string) //OR var m = make(map[string]string) Map literal( last trailing comma is necessary ): m := map[string]int{ \"First\": 100, \"Second\": 80, // comma is necessary } Add new key-value pair Syntax : m[key] = value func main() { m := map[string]int{ \"First\": 100, \"Second\": 80, } fmt.Println(m) m[\"Third\"] = 70 fmt.Println(m) } Go Playground Update value func main() { m := map[string]int{ \"First\": 100, \"Second\": 80, } m[\"First\"] = 0 m[\"Second\"] = 0 fmt.Println(m) } Go Playground Iterating over a map func main() { m := map[string]int{ \"First\": 100, \"Second\": 80, } for key, value := range m { fmt.Printf(\"Key:%v\\tValue:%v\\n\", key, value) } } Go Playground Verify if a key exists or not A map key can also return a second value, a Boolean. If the key exists, it will return true, or false if the key is not present. func main() { listOfName := []string{\"John\", \"Mary\", \"Jane\"} for _, name := range listOfName{ grades(name) } } func grades(name string) { students := map[string]float64{ \"John\": 91.7, \"Jane\": 92, } grade, ok := students[name] // the second value if !ok { // if false OR if not true fmt.Printf(\"No grade for %v!!!\\n\", name) } else if grade < 60 { fmt.Printf(\"%v is failing.\\n\", name) } else { fmt.Printf(\"%v is doing well.\\n\", name) } } Go Playground Delete a key The built-in delete() function will remove the key and its value. Syntax : delete(map, \"KEY\") func main() { m := map[string]string{ \"Team A\": \"Champions\", \"Team B\": \"Losers\", } fmt.Println(m) delete(m, \"Team B\") fmt.Println(m) } Go Playground Maps can't contain duplicate keys func main() { test := map[string]int{ \"one\": 1, \"two\": 2, \"three\": 1, \"one\": 20, // duplicate } fmt.Println(test) } The above code will produce this error: ./prog.go:13:3: duplicate key \"one\" in map literal previous key at ./prog.go:10:3 Go Playground Incrementing values Syntax : map[Key]++ package main import ( \"fmt\" ) func main() { // list of names names := []string{\"Willy Denis\", \"Billy Markovich\", \"John Carpenter\", \"Willy Denis\", \"Billy Markovich\", \"John Carpenter\", \"Willy Denis\", \"Billy Markovich\",} // initialize a map votes := make(map[string]int) // range over the slice of names for _, name := range names { // leave off the index votes[name]++ // use the slice's elements as keys and increment its value by one // uncomment the following line to see what's happening //fmt.Println(votes) } fmt.Println(\"The total number of candidates is\", len(votes)) fmt.Println() for key, value := range votes { fmt.Printf(\"%v has %v votes.\\n\", key, value) } } Go Playground Diff maps for duplicate values https://stackoverflow.com/questions/57236845/checking-if-map-has-duplicate-values-in-go Map as a function argument If a variable is pointing to an already initialized map.... https://medium.com/wesionary-team/pointers-and-passby-value-reference-in-golang-a00c8c59b7f1 https://www.youtube.com/watch?v=SEd9baxsfEA Copy a map https://stackoverflow.com/questions/23057785/how-to-copy-a-map Define your own type Structs A struct is a user defined type. It's constructed by grouping multiple values of a single or multiple types together to form a blueprint. Define a struct You declare a struct by using the struct keyword as its type. Each field consists of a field name and a field type: func main() { var person struct { name string age int employed bool } person.name = \"John\" person.age = 30 person.employed = false fmt.Println(\"My name is\", person.name) fmt.Println(\"I am\", person.age, \"years old\") if person.employed { fmt.Println(\"I am currently\", person.employed) } To create another person, we would have to define a whole new struct (including all its fields)all over again. Go Playground Define a struct type With a user defined struct, you just need to create a struct type once, and then use it as a blueprint to create an instance of that type. Syntax: type [StructName] struct{Field FieldType} package main import ( \"fmt\" ) // struct type of a person type person struct { name string age int employed bool } func main() { // a struct literal john := person{ name: \"John\", age: 30, employed: true, // last comma is mandatory } fmt.Println(john.name) var jane person // create another person jane.name = \"Jane\" jane.age = 65 jane.employed = false fmt.Println(jane) } Go Playground Struct defined type as a function parameter package main import ( \"fmt\" ) type person struct { name string age int employed bool } func getInfo(p person){ // of type person fmt.Println(\"Name is\", p.name) fmt.Println(\"Age is\", p.age) fmt.Println(\"Is employed ?\", p.employed) } func main() { var john person john.name = \"John\" john.age = 30 john.employed = false getInfo(john) } Go Playground Try https://www.digitalocean.com/community/tutorials/how-to-use-struct-tags-in-go Use a pointer to modify a struct with a function A pointer is needed to modify a struct. Without a pointer, the function will obtain a copy of the struct, and the original data won't be updated. package main import ( \"fmt\" ) type customer struct { name string total int } func discount(c *customer) { // take a pointer to a struct c.total = c.total / 2 } func main() { var customer1 customer customer1.name = \"John\" customer1.total = 50 discount(&customer1) // pass a pointer fmt.Println(customer1.total) } Go Playground https://medium.com/a-journey-with-go/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963 Return a pointer to a struct package main import ( \"fmt\" ) var( pl = fmt.Println ) type customer struct { name string rate float64 subscription bool } func newCustomer(name string) *customer { //returns a pointer to a struct var c customer c.name = name c.rate = 2.99 c.subscription = true return &c } func discount(c *customer) { // takes a pointer c.rate = 1.99 pl(\"Discount Applied\") pl() } func customerInfo(c *customer) { //takes a pointer pl(\"Name:\", c.name) pl(\"Monthly Rate:\", c.rate) pl(\"Active ?\", c.subscription) } func main() { kavish := newCustomer(\"Kavish\") // now the variable kavish is a struct pointer customerInfo(kavish) pl() discount(kavish) customerInfo(kavish) } Go Playground Embedding Anonymous Struct Fields There's 3 structure - Employee, Customer, and Address: package embeddedstructs type Employee struct { Name string Age int Department string Salary float64 Address } type Customer struct { Name string Age int Rate float64 Address } type Address struct { Street string City string State string PostalCode string } The Address field can be accessed as if it's embedded in both Employee and Customer : package main import ( \"fmt\" \"testing/embeddedstructs\" // the file is located in ) // $HOME/go/src/testing/embeddingstructs/embeddingstructs.go var ( pl = fmt.Println ) func main() { customer1 := embeddedstructs.Customer{Name: \"Kavish Gour\"} customer1.Street = \"2eme Arrondissement\" customer1.City = \"Paris\" customer1.State = \"France\" customer1.PostalCode = \"75002\" pl(\"Customer Info\") pl(\"--------------\") pl(\"Name:\", customer1.Name) pl(\"Street:\", customer1.Street) pl(\"City:\", customer1.City) pl(\"State:\", customer1.State) pl(\"PostalCode:\", customer1.PostalCode) pl() employee := embeddedstructs.Employee{Name: \"Jean Delatour\"} employee.Street = \"4eme Arrondissement\" employee.City = \"Paris\" employee.State = \"France\" employee.PostalCode = \"75004\" pl(\"Employee Info\") pl(\"--------------\") pl(\"Name:\", employee.Name) pl(\"Street:\", employee.Street) pl(\"City:\", employee.City) pl(\"State:\", employee.State) pl(\"PostalCode:\", employee.PostalCode) } Methods https://medium.com/rungo/structures-in-go-76377cc106a2 https://medium.com/rungo/interfaces-in-go-ab1601159b3a https://medium.com/rungo/anatomy-of-methods-in-go-f552aaa8ac4a Encapsulation https://www.digitalocean.com/community/tutorials/defining-structs-in-go https://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/ Package Visibility https://www.digitalocean.com/community/tutorials/understanding-package-visibility-in-go","title":"Golang"},{"location":"golang/#golang","text":"","title":"Golang"},{"location":"golang/#pointers","text":"A Pointer is a variable that stores the memory address of another variable. A variable can contain any type of values, but when a variable has a memory address as its value, it's called a pointer. To create a pointer, an & operator is used to retrieve the memory address of a variable: var x = 101 // an integer as its value var ptr = &x // get the memory address of x and stores it in a variable called ptr The &x retrieves the memory address of x and stores it in ptr . A complete example: package main import \"fmt\" var p = fmt.Println func main() { var x = 101 var ptr = &x p(\"The memory address of x:\", &x) p(\"The memory address of ptr:\", &ptr) p(\"The value of ptr:\", ptr) } // output The memory address of x: 0xc0000b4020 The memory address of ptr: 0xc0000b6018 The value of ptr: 0xc0000b4020 Go Playground Every variable represents a memory address pointing to a value like so: 0xc0000b6018 = 101 A variable pointing to a memory address of another variable is called a pointer.","title":"Pointers"},{"location":"golang/#dereferencing-a-pointer","text":"Dereferencing is used to access or manipulate data contained in a memory location pointed to by a pointer variable or simply pointer. To access or manipulate the data of a pointer or to dereference a pointer, an * operator is used in front of the pointer variable: package main import \"fmt\" var p = fmt.Println func main() { var x = \"Having fun with pointers\" // declare a varible with data of type string var ptr = &x // store the memory address of variable, hence a pointer p(*ptr) // print the value of the pointer *ptr = \"Still having fun with pointers\" // dereference the pointer with new data p(x) // print the new data } Go Playground","title":"Dereferencing a Pointer"},{"location":"golang/#a-pointer-as-an-argument-in-a-function","text":"To define a function() that takes a memory address as an argument or simply a pointer, *T is used as the type. In this case, *int which stands for a pointer to an int, or a memory address whose value is an int. You give the function() a memory address by prepending the variable with an & operator. Inside the function, an * is used to access the value, hence dereferencing a pointer. package main import ( \"fmt\" ) func zero(ptr *int){ // *int means: I need a memory address that points to data of type int // behind the scene, ptr will point to a memory address that looks like this (in hexadecimal): ptr = 0xc00002c008 // on the next line, the asterisk '*' is used again(now in front of the pointer variable) // to dereference the pointer, hence access/manipulate the value stored in that particular // memory address // behind the scene => replace the current value of 0xc00002c008 or ptr with 0 *ptr = 0 // store 0 in the memory address *ptr is refering to // if I write: ptr = 0 // the go compiler will return an error saying: cannot use 0 (type int) as type *int in assignment // because ptr is like: var ptr *int // ptr will only accept or store a memory address as its value // // you can't just assign a value in it // you have to dereference it first } func main() { x := 5 zero(&x) // the & operator finds the address of variable x fmt.Println(x) } Go Playground","title":"A Pointer as an Argument in a Function"},{"location":"golang/#assignment-operators","text":"","title":"Assignment Operators"},{"location":"golang/#loops","text":"The beauty of Go's For loop is that it merges many modern style of looping into one keyword . Loops always begin with the for keyword.","title":"Loops"},{"location":"golang/#_1","text":"","title":""},{"location":"golang/#init-condition-and-post-optional","text":"func main() { for i := 0; i <=3; i++{ fmt.Println(i) } } Initialize a statement - i := 0 Condition that determine if the loop has to continue or stop - i <= 3 Post statement runs if condition is true - i++ (including the loop block {}) The variable i is only visible in the loop block.","title":"Init, Condition, and Post (optional)"},{"location":"golang/#while-loop","text":"To construct a while loop , omit the init and post statement: package main import ( \"fmt\" ) func main() { i := 0 // declared outside of loop block fmt.Println(\"i is\", i) for i < 5{ // while true, keep looping i++ fmt.Println(\"Now i is\", i) } // end of loop block fmt.Println() fmt.Println(\"Final is\", i) }","title":"While loop"},{"location":"golang/#infinite-loop","text":"","title":"Infinite loop"},{"location":"golang/#forrange-loop","text":"","title":"For...range loop"},{"location":"golang/#continue-and-break","text":"","title":"Continue and Break"},{"location":"golang/#slice","text":"A slice is a dynamic container that hold elements of the same type. It's build on top of an array. https://play.golang.org/p/GJrrw1BYo_O","title":"Slice"},{"location":"golang/#slice-literal","text":"A slice literal is used when you already know what values it will contain: package main import ( \"fmt\" ) func main() { s := []string{\"a\", \"b\", \"c\", \"d\"} fmt.Println(s) }","title":"Slice Literal"},{"location":"golang/#two-ways-to-create-an-empty-or-nil-slice","text":"Initialize an empty slice with a nil value: var mySlice []int According to Golang Wiki , the former is the preferred way. Using the builtin make function to create an empty slice (non-nil): mySlice := make([]string, 0, 10) The syntax: make([]T, length, capacity) Full example: package main import ( \"fmt\" ) func main() { mySlice := make([]int, 5, 10) fmt.Printf(\"mySlice is of type %T\\nIts length is %v\\nIts capacity is %v\", mySlice, len(mySlice), cap(mySlice)) } Output: mySlice is of type []int Its length is 5 Its capacity is 10 To create a slice with a length or capacity, use make() Go Playground There's another shortcut: slice := []string{} The above slice is empty with a length of zero instead of nil(non-nil slice). Note: In most cases, empty slice and nil slice can be treated the same. In some cases, they should be treated differently, one of them is when doing JSON encoding. An empty slice will be encoded as an [] in JSON while nil slice will be encoded as null .","title":"Two ways to create an empty or nil slice"},{"location":"golang/#forrange-loop-over-a-slice","text":"The recommended way to iterate over a slice is by using a for...range loop: package main import ( \"fmt\" ) func main() { mySlice := []int{1, 2, 3, 4, 5} for i, v := range mySlice { fmt.Printf(\"Index %v has the value of %v\\n\", i, v) } } Go Playground","title":"for...range loop over a slice"},{"location":"golang/#slicing-a-slice","text":"Slicing is used to access an individual or a slice of an array. Why a slice of an array? Because slices are built on top of arrays. If you change an array, the result will reflect in the slice. To use the slice operator, two indexes are required : where the slice should start, and where the slice should stop, but not including it. Slicing from index 0 to 4 : package main import \"fmt\" func main() { underlyingArray := [5]string{\"g\", \"o\", \"l\", \"a\", \"n\", \"g\"} slice := underlyingArray[0:4] fmt.Println(slice) } Output is: [g o l a] The second index is the index the slice will stop before. Slice from index 1 till the end package main import ( \"fmt\" \"os\" ) func main() { slice := os.Args[1:] for _, v := range slice { go doSomethingAmazing(v) } } Take a list of arguments from standard input and slice from index 1 till the end. Index 0 or the name of the Go script is discarded. Slice from index 0 till index 4 If you omit the start index, 0 will be used as default: package main import ( \"fmt\" \"os\" ) func main() { underlyingArray := [5]int{1, 2, 3, 4, 5} slice := os.Args[:3] for i, v := range slice { fmt.Printf(\"Index %v has the value of %v.\", i, v) } } Output is: [1 2 3]","title":"Slicing a slice"},{"location":"golang/#appending-to-a-slice","text":"The built-in append function , appends element to the end of a slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself. The anatomy of the append function : func append(slice []Type, elems ...Type) []Type It takes a slice as the first parameter, and the second parameter can be an unlimited number of elements of the same type or another slice(unfurled with an elipsis). And it returns a slice. That's why it's recommended to store the result in the slice that we're appending values to. Example: package main import ( \"fmt\" \"bufio\" \"os\" ) func main() { var slice []string // initialize a nil slice fmt.Println(slice) // slice is nil sc := bufio.NewScanner(os.Stdin) // take parameters from standard input for sc.Scan() { // loop over lines of input slice = append(slice, sc.Text()) // append each line to the slice } fmt.Println(slice) // results } Try it: echo -e \"1\\n2\\n3\\n4\" | go run main.go","title":"Appending to a slice"},{"location":"golang/#passing-slices-to-a-variadic-function","text":"package main import ( \"fmt\" \"strings\" ) func main() { s := []string{\"Go\", \"is\", \"my\", \"favourite\", \"Programming\", \"Language\"} // creates a slice of string with 6 elements result := concatStrings(s...) // unfurl the slice with an elipsis and pass it to the function fmt.Println(result) // prints the result } func concatStrings(sentence ...string) string { var sum string for _, v := range sentence { sum += v + \" \" // concatenate all elements } sum = strings.TrimSpace(sum) // remove leading and trailing spaces return sum + \".\" // add a dot at the end } Go Playground","title":"Passing Slices to a Variadic Function"},{"location":"golang/#the-danger-of-appending-to-a-slice-that-already-has-a-length-and-a-capacity","text":"package main import ( \"fmt\" ) func main() { numbers := []int{11, 12, 13} mySlice := make([]int, 5, 10) for _, v := range numbers{ mySlice = append(mySlice, v) } fmt.Println(mySlice) } Output: [0 0 0 0 0 11 12 13] One of the ways to make use of an empty slice: package main import ( \"fmt\" ) func main() { candidates := []string{\"macOS\", \"OpenBSD\", \"Linux\"} // number of votes votes := []string{\"macOS\", \"OpenBSD\", \"Linux\", \"macOS\", \"OpenBSD\", \"macOS\"} // make an empty slice with the length of the total number of candidates counts := make([]int, len(candidates)) for _, vote := range votes { matched := false for i, candidate := range candidates { if candidate == vote { counts[i]++ matched = true } } if matched == false { candidates = append(candidates, vote) counts = append(counts, 1) } } for i, candidate := range candidates { fmt.Printf(\"%s: %d\\n\", candidate, counts[i]) } } Go Playground","title":"The danger of appending to a slice that already has a length and a capacity"},{"location":"golang/#update-entries-in-a-loop","text":"num := []int{11, 12, 13} for _, n := range num { n += 1 } fmt.Println(s) // Output: [11 12 13] The thing is, all the values is being copied one by one to a local variable n ; the slice remained intact. That's why in certain situation, we have to use pointers. To update the slice, call the slice itself: num := []int{11, 12, 13} for i := range num { // n: value is not needed s[i] =+ 1 } fmt.Println(s) // Output: [12 13 14]","title":"Update entries in a loop"},{"location":"golang/#remove-duplicate-values-from-a-slice","text":"https://www.golangprograms.com/remove-duplicate-values-from-slice.html","title":"remove duplicate values from a slice"},{"location":"golang/#maps","text":"A map is an unordered list of key-value pairs. It's a dynamic data structure. It can't contain dupicate keys.","title":"Maps"},{"location":"golang/#create-an-empty-map-and-a-map-literal","text":"Empty map: Syntax : make(map[KeyType]ValueType) m := make(map[string]string) //OR var m = make(map[string]string) Map literal( last trailing comma is necessary ): m := map[string]int{ \"First\": 100, \"Second\": 80, // comma is necessary }","title":"Create an empty map, and a map literal"},{"location":"golang/#add-new-key-value-pair","text":"Syntax : m[key] = value func main() { m := map[string]int{ \"First\": 100, \"Second\": 80, } fmt.Println(m) m[\"Third\"] = 70 fmt.Println(m) } Go Playground","title":"Add new key-value pair"},{"location":"golang/#update-value","text":"func main() { m := map[string]int{ \"First\": 100, \"Second\": 80, } m[\"First\"] = 0 m[\"Second\"] = 0 fmt.Println(m) } Go Playground","title":"Update value"},{"location":"golang/#iterating-over-a-map","text":"func main() { m := map[string]int{ \"First\": 100, \"Second\": 80, } for key, value := range m { fmt.Printf(\"Key:%v\\tValue:%v\\n\", key, value) } } Go Playground","title":"Iterating over a map"},{"location":"golang/#verify-if-a-key-exists-or-not","text":"A map key can also return a second value, a Boolean. If the key exists, it will return true, or false if the key is not present. func main() { listOfName := []string{\"John\", \"Mary\", \"Jane\"} for _, name := range listOfName{ grades(name) } } func grades(name string) { students := map[string]float64{ \"John\": 91.7, \"Jane\": 92, } grade, ok := students[name] // the second value if !ok { // if false OR if not true fmt.Printf(\"No grade for %v!!!\\n\", name) } else if grade < 60 { fmt.Printf(\"%v is failing.\\n\", name) } else { fmt.Printf(\"%v is doing well.\\n\", name) } } Go Playground","title":"Verify if a key exists or not"},{"location":"golang/#delete-a-key","text":"The built-in delete() function will remove the key and its value. Syntax : delete(map, \"KEY\") func main() { m := map[string]string{ \"Team A\": \"Champions\", \"Team B\": \"Losers\", } fmt.Println(m) delete(m, \"Team B\") fmt.Println(m) } Go Playground","title":"Delete a key"},{"location":"golang/#maps-cant-contain-duplicate-keys","text":"func main() { test := map[string]int{ \"one\": 1, \"two\": 2, \"three\": 1, \"one\": 20, // duplicate } fmt.Println(test) } The above code will produce this error: ./prog.go:13:3: duplicate key \"one\" in map literal previous key at ./prog.go:10:3 Go Playground","title":"Maps can't contain duplicate keys"},{"location":"golang/#incrementing-values","text":"Syntax : map[Key]++ package main import ( \"fmt\" ) func main() { // list of names names := []string{\"Willy Denis\", \"Billy Markovich\", \"John Carpenter\", \"Willy Denis\", \"Billy Markovich\", \"John Carpenter\", \"Willy Denis\", \"Billy Markovich\",} // initialize a map votes := make(map[string]int) // range over the slice of names for _, name := range names { // leave off the index votes[name]++ // use the slice's elements as keys and increment its value by one // uncomment the following line to see what's happening //fmt.Println(votes) } fmt.Println(\"The total number of candidates is\", len(votes)) fmt.Println() for key, value := range votes { fmt.Printf(\"%v has %v votes.\\n\", key, value) } } Go Playground","title":"Incrementing values"},{"location":"golang/#diff-maps-for-duplicate-values","text":"https://stackoverflow.com/questions/57236845/checking-if-map-has-duplicate-values-in-go","title":"Diff maps for duplicate values"},{"location":"golang/#map-as-a-function-argument","text":"If a variable is pointing to an already initialized map.... https://medium.com/wesionary-team/pointers-and-passby-value-reference-in-golang-a00c8c59b7f1 https://www.youtube.com/watch?v=SEd9baxsfEA","title":"Map as a function argument"},{"location":"golang/#copy-a-map","text":"https://stackoverflow.com/questions/23057785/how-to-copy-a-map","title":"Copy a map"},{"location":"golang/#define-your-own-type","text":"","title":"Define your own type"},{"location":"golang/#structs","text":"A struct is a user defined type. It's constructed by grouping multiple values of a single or multiple types together to form a blueprint.","title":"Structs"},{"location":"golang/#define-a-struct","text":"You declare a struct by using the struct keyword as its type. Each field consists of a field name and a field type: func main() { var person struct { name string age int employed bool } person.name = \"John\" person.age = 30 person.employed = false fmt.Println(\"My name is\", person.name) fmt.Println(\"I am\", person.age, \"years old\") if person.employed { fmt.Println(\"I am currently\", person.employed) } To create another person, we would have to define a whole new struct (including all its fields)all over again. Go Playground","title":"Define a struct"},{"location":"golang/#define-a-struct-type","text":"With a user defined struct, you just need to create a struct type once, and then use it as a blueprint to create an instance of that type. Syntax: type [StructName] struct{Field FieldType} package main import ( \"fmt\" ) // struct type of a person type person struct { name string age int employed bool } func main() { // a struct literal john := person{ name: \"John\", age: 30, employed: true, // last comma is mandatory } fmt.Println(john.name) var jane person // create another person jane.name = \"Jane\" jane.age = 65 jane.employed = false fmt.Println(jane) } Go Playground","title":"Define a struct type"},{"location":"golang/#struct-defined-type-as-a-function-parameter","text":"package main import ( \"fmt\" ) type person struct { name string age int employed bool } func getInfo(p person){ // of type person fmt.Println(\"Name is\", p.name) fmt.Println(\"Age is\", p.age) fmt.Println(\"Is employed ?\", p.employed) } func main() { var john person john.name = \"John\" john.age = 30 john.employed = false getInfo(john) } Go Playground","title":"Struct defined type as a function parameter"},{"location":"golang/#try","text":"https://www.digitalocean.com/community/tutorials/how-to-use-struct-tags-in-go","title":"Try"},{"location":"golang/#use-a-pointer-to-modify-a-struct-with-a-function","text":"A pointer is needed to modify a struct. Without a pointer, the function will obtain a copy of the struct, and the original data won't be updated. package main import ( \"fmt\" ) type customer struct { name string total int } func discount(c *customer) { // take a pointer to a struct c.total = c.total / 2 } func main() { var customer1 customer customer1.name = \"John\" customer1.total = 50 discount(&customer1) // pass a pointer fmt.Println(customer1.total) } Go Playground https://medium.com/a-journey-with-go/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963","title":"Use a pointer to modify a struct with a function"},{"location":"golang/#return-a-pointer-to-a-struct","text":"package main import ( \"fmt\" ) var( pl = fmt.Println ) type customer struct { name string rate float64 subscription bool } func newCustomer(name string) *customer { //returns a pointer to a struct var c customer c.name = name c.rate = 2.99 c.subscription = true return &c } func discount(c *customer) { // takes a pointer c.rate = 1.99 pl(\"Discount Applied\") pl() } func customerInfo(c *customer) { //takes a pointer pl(\"Name:\", c.name) pl(\"Monthly Rate:\", c.rate) pl(\"Active ?\", c.subscription) } func main() { kavish := newCustomer(\"Kavish\") // now the variable kavish is a struct pointer customerInfo(kavish) pl() discount(kavish) customerInfo(kavish) } Go Playground","title":"Return a pointer to a struct"},{"location":"golang/#embedding-anonymous-struct-fields","text":"There's 3 structure - Employee, Customer, and Address: package embeddedstructs type Employee struct { Name string Age int Department string Salary float64 Address } type Customer struct { Name string Age int Rate float64 Address } type Address struct { Street string City string State string PostalCode string } The Address field can be accessed as if it's embedded in both Employee and Customer : package main import ( \"fmt\" \"testing/embeddedstructs\" // the file is located in ) // $HOME/go/src/testing/embeddingstructs/embeddingstructs.go var ( pl = fmt.Println ) func main() { customer1 := embeddedstructs.Customer{Name: \"Kavish Gour\"} customer1.Street = \"2eme Arrondissement\" customer1.City = \"Paris\" customer1.State = \"France\" customer1.PostalCode = \"75002\" pl(\"Customer Info\") pl(\"--------------\") pl(\"Name:\", customer1.Name) pl(\"Street:\", customer1.Street) pl(\"City:\", customer1.City) pl(\"State:\", customer1.State) pl(\"PostalCode:\", customer1.PostalCode) pl() employee := embeddedstructs.Employee{Name: \"Jean Delatour\"} employee.Street = \"4eme Arrondissement\" employee.City = \"Paris\" employee.State = \"France\" employee.PostalCode = \"75004\" pl(\"Employee Info\") pl(\"--------------\") pl(\"Name:\", employee.Name) pl(\"Street:\", employee.Street) pl(\"City:\", employee.City) pl(\"State:\", employee.State) pl(\"PostalCode:\", employee.PostalCode) }","title":"Embedding Anonymous Struct Fields"},{"location":"golang/#methods","text":"https://medium.com/rungo/structures-in-go-76377cc106a2 https://medium.com/rungo/interfaces-in-go-ab1601159b3a https://medium.com/rungo/anatomy-of-methods-in-go-f552aaa8ac4a","title":"Methods"},{"location":"golang/#encapsulation","text":"https://www.digitalocean.com/community/tutorials/defining-structs-in-go https://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/","title":"Encapsulation"},{"location":"golang/#package-visibility","text":"https://www.digitalocean.com/community/tutorials/understanding-package-visibility-in-go","title":"Package Visibility"},{"location":"grep/","text":"Grep Lines that begin with a slash and end with .js find . -type f | html-tool attribs src | grep '\\.js$' | egrep '^ */' Find dotdotslash grep -Hrn \"\\.\\./\" *","title":"Grep"},{"location":"grep/#grep","text":"","title":"Grep"},{"location":"grep/#lines-that-begin-with-a-slash-and-end-with-js","text":"find . -type f | html-tool attribs src | grep '\\.js$' | egrep '^ */'","title":"Lines that begin with a slash and end with .js"},{"location":"grep/#find-dotdotslash","text":"grep -Hrn \"\\.\\./\" *","title":"Find dotdotslash"},{"location":"regexburp/","text":"Regex For Burp Suite search Find JWT token \\b(ey[a-z0-9+\\-\\._]+[=|==|\\s|;|\"]) Email ID \\b[\\w\\.\\!\\$\\+\\-\\/\\=\\?\\_\\~]+@[\\w]+\\.[\\w]+\\b Subdomains \\b[\\w\\.\\-\\\\\\/%\\*]*(\\.twitter)\\.(com)\\b Find IP addresses \\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b Internal IP address \\b(192|10|172)\\.(\\d\\d\\d|\\d\\d|\\d)\\.(\\d\\d\\d|\\d\\d|\\d)\\.(\\d\\d\\d|\\d\\d|\\d)\\b","title":"Regex For Burp Suite search"},{"location":"regexburp/#regex-for-burp-suite-search","text":"","title":"Regex For Burp Suite search"},{"location":"regexburp/#find-jwt-token","text":"\\b(ey[a-z0-9+\\-\\._]+[=|==|\\s|;|\"])","title":"Find JWT token"},{"location":"regexburp/#email-id","text":"\\b[\\w\\.\\!\\$\\+\\-\\/\\=\\?\\_\\~]+@[\\w]+\\.[\\w]+\\b","title":"Email ID"},{"location":"regexburp/#subdomains","text":"\\b[\\w\\.\\-\\\\\\/%\\*]*(\\.twitter)\\.(com)\\b","title":"Subdomains"},{"location":"regexburp/#find-ip-addresses","text":"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b","title":"Find IP addresses"},{"location":"regexburp/#internal-ip-address","text":"\\b(192|10|172)\\.(\\d\\d\\d|\\d\\d|\\d)\\.(\\d\\d\\d|\\d\\d|\\d)\\.(\\d\\d\\d|\\d\\d|\\d)\\b","title":"Internal IP address"},{"location":"sed/","text":"sed Remove ANSI codes/colors On Linux: ./somescript | sed -r \"s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g\" On OSX or BSD(in some cases use -E ): ./somescript | sed $'s,\\x1b\\\\[[0-9;]*[a-zA-Z],,g'","title":"Sed"},{"location":"sed/#sed","text":"","title":"sed"},{"location":"sed/#remove-ansi-codescolors","text":"On Linux: ./somescript | sed -r \"s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g\" On OSX or BSD(in some cases use -E ): ./somescript | sed $'s,\\x1b\\\\[[0-9;]*[a-zA-Z],,g'","title":"Remove ANSI codes/colors"},{"location":"vim/","text":"Vim Editor Vimrc let mapleader = \"\\<space>\" syntax on let g:pymode_python = 'python3' \" sort the buffer for unique lines nmap <Leader>s :%!sort -u --version-sort<CR> \" Base64 decode word under cursor nmap <Leader>b :!echo <C-R><C-W> \\| base64 -D<CR> set hlsearch Open file under cursor in a new tab: # Press CTRL+'w' then 'f' <C-W>f Execute shell command on the data that is in the vim buffer or file :%! sort -u Run shell commands and put the output in the vim buffer or file Hit ! twice, and you'll get a vim prompt in the bottom left corner that looks like this: :.! Then just type your command and press enter: :.!whoami In fish shell, make a universal variable (or else vim won't work properly) set -U EDITOR vim Pipe data into a vim buffer: grep -Hnri * | vim - Sort the fifth column # to look at content size :%!find . -type f -exec ls -l {} \\; # sort based on fifth column :%! sort -k5,5 -n Enable Backspace set backspace=indent,eol,start","title":"Vim"},{"location":"vim/#vim-editor","text":"","title":"Vim Editor"},{"location":"vim/#vimrc","text":"let mapleader = \"\\<space>\" syntax on let g:pymode_python = 'python3' \" sort the buffer for unique lines nmap <Leader>s :%!sort -u --version-sort<CR> \" Base64 decode word under cursor nmap <Leader>b :!echo <C-R><C-W> \\| base64 -D<CR> set hlsearch","title":"Vimrc"},{"location":"vim/#open-file-under-cursor-in-a-new-tab","text":"# Press CTRL+'w' then 'f' <C-W>f","title":"Open file under cursor in a new tab:"},{"location":"vim/#execute-shell-command-on-the-data-that-is-in-the-vim-buffer-or-file","text":":%! sort -u","title":"Execute shell command on the data that is in the vim buffer or file"},{"location":"vim/#run-shell-commands-and-put-the-output-in-the-vim-buffer-or-file","text":"Hit ! twice, and you'll get a vim prompt in the bottom left corner that looks like this: :.! Then just type your command and press enter: :.!whoami","title":"Run shell commands and put the output in the vim buffer or file"},{"location":"vim/#in-fish-shell-make-a-universal-variableor-else-vim-wont-work-properly","text":"set -U EDITOR vim","title":"In fish shell, make a universal variable(or else vim won't work properly)"},{"location":"vim/#pipe-data-into-a-vim-buffer","text":"grep -Hnri * | vim -","title":"Pipe data into a vim buffer:"},{"location":"vim/#sort-the-fifth-column","text":"# to look at content size :%!find . -type f -exec ls -l {} \\; # sort based on fifth column :%! sort -k5,5 -n","title":"Sort the fifth column"},{"location":"vim/#enable-backspace","text":"set backspace=indent,eol,start","title":"Enable Backspace"},{"location":"xargs/","text":"xargs Decode base64 inside vim Parse lines of data to xargs ( -d on linux): :%! xargs -n1 -I{} sh -c 'echo {} | base64 -D' Note: Omit sh -c if you're using bash","title":"Xargs"},{"location":"xargs/#xargs","text":"","title":"xargs"},{"location":"xargs/#decode-base64-inside-vim","text":"Parse lines of data to xargs ( -d on linux): :%! xargs -n1 -I{} sh -c 'echo {} | base64 -D' Note: Omit sh -c if you're using bash","title":"Decode base64 inside vim"}]}