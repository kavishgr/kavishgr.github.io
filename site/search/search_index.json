{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notes to self Go back to my blog","title":"Home"},{"location":"#notes-to-self","text":"Go back to my blog","title":"Notes to self"},{"location":"bash_alias/","text":"Bash Alias Vim Sort by size alias vimsize='find . -type f -exec ls -l {} \\; | vim -' Then run: :%! sort -k5,5 -n Grep New version of grep: alias egrep='/usr/local/opt/grep/bin/gegrep' alias fgrep='/usr/local/opt/grep/bin/gfgrep' alias grep='/usr/local/opt/grep/bin/ggrep --color=always' Find dotdot slash: alias gdot='grep -Hrn \"\\.\\./\" * '","title":"Bash Alias"},{"location":"bash_alias/#bash-alias","text":"","title":"Bash Alias"},{"location":"bash_alias/#vim","text":"","title":"Vim"},{"location":"bash_alias/#sort-by-size","text":"alias vimsize='find . -type f -exec ls -l {} \\; | vim -' Then run: :%! sort -k5,5 -n","title":"Sort by size"},{"location":"bash_alias/#grep","text":"","title":"Grep"},{"location":"bash_alias/#new-version-of-grep","text":"alias egrep='/usr/local/opt/grep/bin/gegrep' alias fgrep='/usr/local/opt/grep/bin/gfgrep' alias grep='/usr/local/opt/grep/bin/ggrep --color=always'","title":"New version of grep:"},{"location":"bash_alias/#find-dotdot-slash","text":"alias gdot='grep -Hrn \"\\.\\./\" * '","title":"Find dotdot slash:"},{"location":"golang/","text":"Golang Pointers A Pointer is a variable that stores the memory address of another variable. A variable can contain any type of values, but when a variable has a memory address as its value, it's called a pointer. To create a pointer, an & operator is used to retrieve the memory address of a variable: var x = 101 // an integer as its value var ptr = &x // get the memory address of x and stores it in a variable called ptr The &x retrieves the memory address of x and stores it in ptr . A complete example: package main import \"fmt\" var p = fmt.Println func main() { var x = 101 var ptr = &x p(\"The memory address of x:\", &x) p(\"The memory address of ptr:\", &ptr) p(\"The value of ptr:\", ptr) } // output The memory address of x: 0xc0000b4020 The memory address of ptr: 0xc0000b6018 The value of ptr: 0xc0000b4020 Go Playground Every variable represents a memory address pointing to a value like so: 0xc0000b6018 = 101 A variable pointing to a memory address of another variable is called a pointer. Dereferencing a Pointer Dereferencing is used to access or manipulate data contained in a memory location pointed to by a pointer variable or simply pointer. To access or manipulate the data of a pointer or to dereference a pointer, an * operator is used in front of the pointer variable: package main import \"fmt\" var p = fmt.Println func main() { var x = \"Having fun with pointers\" // declare a varible with data of type string var ptr = &x // store the memory address of variable, hence a pointer p(*ptr) // print the value of the pointer *ptr = \"Still having fun with pointers\" // dereference the pointer with new data p(x) // print the new data } Go Playground https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back https://medium.com/@Kabilan1290/journey-of-my-first-bug-bounty-72175d903ce3 https://medium.com/bugbountywriteup/introduction-to-bug-bounty-for-noobs-46654bd6e0e2 https://hackingarise.com/xss-dorking/ https://craighays.com/bug-bounty-hunting-tips-6-simplify/ A Pointer as an Argument in a Function To define a function() that takes a memory address as an argument or simply a pointer, *T is used as the type. In this case, *int which stands for a pointer to an int, or a memory address whose value is an int. You give the function() a memory address by prepending the variable with an & operator. Inside the function, an * is used to access the value, hence dereferencing a pointer. package main import ( \"fmt\" ) func zero(ptr *int){ // *int means: i need a memory address that points to data of type int // behind the scene, ptr will point to a memory address that looks like this (in hexadecimal): ptr = 0xc00002c008 // on the next line, the asterisk '*' is used again(now in front of the pointer variable) // to dereference the pointer, hence access/manipulate the value stored in that particular // memory address // behind the scene => replace the value of 0xc00002c008 with 0 *ptr = 0 // store 0 in the memory address *ptr is refering to // if i write: ptr = 0 // the go compiler will return an error saying: cannot use 0 (type int) as type *int in assignment // because ptr is like: var ptr *int // ptr will only accept or store a memory address as its value // // you can't just assign a value in it // you have to dereference it first } func main() { x := 5 zero(&x) // the & operator finds the address of variable x fmt.Println(x) } Go Playground Assignment Operators Loops The beauty of Go's For loop is that it merges many modern style of looping into one keyword . Loops always begin with the for keyword. Init, Condition, and Post (optional) func main() { for i := 0; i <=3; i++{ fmt.Println(i) } Initialize a statement - i := 0 Condition that determine if the loop has to continue or stop - i <= 3 Post statement runs if condition is true - i++ (including the loop block {}) The variable i is only visible in the loop block. While loop To construct a while loop , omit the init and post statement: package main import ( \"fmt\" ) func main() { i := 0 // declared outside of loop block fmt.Println(\"i is\", i) for i < 5{ // while true, keep looping i++ fmt.Println(\"Now i is\", i) } // end of loop block fmt.Println() fmt.Println(\"Final is\", i) } Infinite loop For...range loop Continue and Break Slice A slice is a dynamic container that hold elements of the same type. It's build on top of an array. https://play.golang.org/p/GJrrw1BYo_O Slice Literal A slice literal is used when you already know what values it will contain: package main import ( \"fmt\" ) func main() { s := []string{\"a\", \"b\", \"c\", \"d\"} fmt.Println(s) } Two ways to create an empty or nil slice Initialize an empty slice with a nil value: var mySlice []int According to Golang Wiki , the former is the preferred way. Using the builtin make function to create an empty slice (non-nil): mySlice := make([]string, 0, 10) The syntax: make([]T, length, capacity) Full example: package main import ( \"fmt\" ) func main() { mySlice := make([]int, 5, 10) fmt.Printf(\"mySlice is of type %T\\nIts length is %v\\nIts capacity is %v\", mySlice, len(mySlice), cap(mySlice)) } Output: mySlice is of type []int Its length is 5 Its capacity is 10 To create a slice with a length or capacity, use make() Go Playground There's another shortcut: slice := []string{} The above slice is empty with a length of zero instead of nil(non-nil slice). Note: In most cases, empty slice and nil slice can be treated the same. In some cases, they should be treated differently, one of them is when doing JSON encoding. An empty slice will be encoded as an [] in JSON while nil slice will be encoded as null . for...range loop over a slice The recommended way to iterate over a slice is by using a for...range loop: package main import ( \"fmt\" ) func main() { mySlice := []int{1, 2, 3, 4, 5} for i, v := range mySlice { fmt.Printf(\"Index %v has the value of %v\\n\", i, v) } } Go Playground Slicing a slice Slicing is used to access an individual or a slice of an array. Why a slice of an array? Because slices are built on top of arrays. If you change an array, the result will reflect in the slice. To use the slice operator, two indexes are required : where the slice should start, and where the slice should stop, but not including it. Slicing from index 0 to 4 : package main import \"fmt\" func main() { underlyingArray := [5]string{\"g\", \"o\", \"l\", \"a\", \"n\", \"g\"} slice := underlyingArray[0:4] fmt.Println(slice) } Output is: [g o l a] The second index is the index the slice will stop before. Slice from index 1 till the end package main import ( \"fmt\" \"os\" ) func main() { slice := os.Args[1:] for _, v := range slice { go doSomethingAmazing(v) } } Take a list of arguments from standard input and slice from index 1 till the end. Index 0 or the name of the Go script is discarded. Slice from index 0 till index 4 If you omit the start index, 0 will be used as default: package main import ( \"fmt\" \"os\" ) func main() { underlyingArray := [5]int{1, 2, 3, 4, 5} slice := os.Args[:3] for i, v := range slice { fmt.Printf(\"Index %v has the value of %v.\", i, v) } } Output is: [1 2 3] Appending to a slice The built-in append function , appends element to the end of a slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself. The anatomy of the append function : func append(slice []Type, elems ...Type) []Type It takes a slice as the first parameter, and the second parameter can be an unlimited number of elements of the same type or another slice(unfurled with an elipsis). And it returns a slice. That's why it's recommended to store the result in the slice that we're appending values to. Example: package main import ( \"fmt\" \"bufio\" \"os\" ) func main() { var slice []string // initialize a nil slice fmt.Println(slice) // slice is nil sc := bufio.NewScanner(os.Stdin) // take parameters from standard input for sc.Scan() { // loop over lines of input slice = append(slice, sc.Text()) // append each line to the slice } fmt.Println(slice) // results } Try it: echo -e \"1\\n2\\n3\\n4\" | go run main.go Passing Slices to a Variadic Function package main import ( \"fmt\" \"strings\" ) func main() { s := []string{\"Go\", \"is\", \"my\", \"favourite\", \"Programming\", \"Language\"} // creates a slice of string with 6 elements result := concatStrings(s...) // unfurl the slice with an elipsis and pass it to the function fmt.Println(result) // prints the result } func concatStrings(sentence ...string) string { var sum string for _, v := range sentence { sum += v + \" \" // concatenate all elements } sum = strings.TrimSpace(sum) // remove leading and trailing spaces return sum + \".\" // add a dot at the end } Go Playground The danger of appending to a slice that already has a length and a capacity package main import ( \"fmt\" ) func main() { numbers := []int{11, 12, 13} mySlice := make([]int, 5, 10) for _, v := range numbers{ mySlice = append(mySlice, v) } fmt.Println(mySlice) } Output: [0 0 0 0 0 11 12 13] One of the ways to make use of an empty slice: package main import ( \"fmt\" ) func main() { candidates := []string{\"macOS\", \"OpenBSD\", \"Linux\"} // number of votes votes := []string{\"macOS\", \"OpenBSD\", \"Linux\", \"macOS\", \"OpenBSD\", \"macOS\"} // make an empty slice with the length of the total number of candidates counts := make([]int, len(candidates)) for _, vote := range votes { matched := false for i, candidate := range candidates { if candidate == vote { counts[i]++ matched = true } } if matched == false { candidates = append(candidates, vote) counts = append(counts, 1) } } for i, candidate := range candidates { fmt.Printf(\"%s: %d\\n\", candidate, counts[i]) } } Go Playground Update entries in a loop num := []int{11, 12, 13} for _, n := range num { n += 1 } fmt.Println(s) // Output: [11 12 13] The thing is, all the values is being copied one by one to a local variable n ; the slice remained intact. That's why in certain situation, we have to use pointers. To update the slice, call the slice itself: num := []int{11, 12, 13} for i := range num { // n: value is not needed s[i] =+ 1 } fmt.Println(s) // Output: [12 13 14] Maps Structs https://pragmaticwebsecurity.com/cheatsheets.html Pointer in a struct https://medium.com/a-journey-with-go/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963 https://medium.com/a-journey-with-go/archive https://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/","title":"Golang"},{"location":"golang/#golang","text":"","title":"Golang"},{"location":"golang/#pointers","text":"A Pointer is a variable that stores the memory address of another variable. A variable can contain any type of values, but when a variable has a memory address as its value, it's called a pointer. To create a pointer, an & operator is used to retrieve the memory address of a variable: var x = 101 // an integer as its value var ptr = &x // get the memory address of x and stores it in a variable called ptr The &x retrieves the memory address of x and stores it in ptr . A complete example: package main import \"fmt\" var p = fmt.Println func main() { var x = 101 var ptr = &x p(\"The memory address of x:\", &x) p(\"The memory address of ptr:\", &ptr) p(\"The value of ptr:\", ptr) } // output The memory address of x: 0xc0000b4020 The memory address of ptr: 0xc0000b6018 The value of ptr: 0xc0000b4020 Go Playground Every variable represents a memory address pointing to a value like so: 0xc0000b6018 = 101 A variable pointing to a memory address of another variable is called a pointer.","title":"Pointers"},{"location":"golang/#dereferencing-a-pointer","text":"Dereferencing is used to access or manipulate data contained in a memory location pointed to by a pointer variable or simply pointer. To access or manipulate the data of a pointer or to dereference a pointer, an * operator is used in front of the pointer variable: package main import \"fmt\" var p = fmt.Println func main() { var x = \"Having fun with pointers\" // declare a varible with data of type string var ptr = &x // store the memory address of variable, hence a pointer p(*ptr) // print the value of the pointer *ptr = \"Still having fun with pointers\" // dereference the pointer with new data p(x) // print the new data } Go Playground https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back https://medium.com/@Kabilan1290/journey-of-my-first-bug-bounty-72175d903ce3 https://medium.com/bugbountywriteup/introduction-to-bug-bounty-for-noobs-46654bd6e0e2 https://hackingarise.com/xss-dorking/ https://craighays.com/bug-bounty-hunting-tips-6-simplify/","title":"Dereferencing a Pointer"},{"location":"golang/#a-pointer-as-an-argument-in-a-function","text":"To define a function() that takes a memory address as an argument or simply a pointer, *T is used as the type. In this case, *int which stands for a pointer to an int, or a memory address whose value is an int. You give the function() a memory address by prepending the variable with an & operator. Inside the function, an * is used to access the value, hence dereferencing a pointer. package main import ( \"fmt\" ) func zero(ptr *int){ // *int means: i need a memory address that points to data of type int // behind the scene, ptr will point to a memory address that looks like this (in hexadecimal): ptr = 0xc00002c008 // on the next line, the asterisk '*' is used again(now in front of the pointer variable) // to dereference the pointer, hence access/manipulate the value stored in that particular // memory address // behind the scene => replace the value of 0xc00002c008 with 0 *ptr = 0 // store 0 in the memory address *ptr is refering to // if i write: ptr = 0 // the go compiler will return an error saying: cannot use 0 (type int) as type *int in assignment // because ptr is like: var ptr *int // ptr will only accept or store a memory address as its value // // you can't just assign a value in it // you have to dereference it first } func main() { x := 5 zero(&x) // the & operator finds the address of variable x fmt.Println(x) } Go Playground","title":"A Pointer as an Argument in a Function"},{"location":"golang/#assignment-operators","text":"","title":"Assignment Operators"},{"location":"golang/#loops","text":"The beauty of Go's For loop is that it merges many modern style of looping into one keyword . Loops always begin with the for keyword.","title":"Loops"},{"location":"golang/#_1","text":"","title":""},{"location":"golang/#init-condition-and-post-optional","text":"func main() { for i := 0; i <=3; i++{ fmt.Println(i) } Initialize a statement - i := 0 Condition that determine if the loop has to continue or stop - i <= 3 Post statement runs if condition is true - i++ (including the loop block {}) The variable i is only visible in the loop block.","title":"Init, Condition, and Post (optional)"},{"location":"golang/#while-loop","text":"To construct a while loop , omit the init and post statement: package main import ( \"fmt\" ) func main() { i := 0 // declared outside of loop block fmt.Println(\"i is\", i) for i < 5{ // while true, keep looping i++ fmt.Println(\"Now i is\", i) } // end of loop block fmt.Println() fmt.Println(\"Final is\", i) }","title":"While loop"},{"location":"golang/#infinite-loop","text":"","title":"Infinite loop"},{"location":"golang/#forrange-loop","text":"","title":"For...range loop"},{"location":"golang/#continue-and-break","text":"","title":"Continue and Break"},{"location":"golang/#slice","text":"A slice is a dynamic container that hold elements of the same type. It's build on top of an array. https://play.golang.org/p/GJrrw1BYo_O","title":"Slice"},{"location":"golang/#slice-literal","text":"A slice literal is used when you already know what values it will contain: package main import ( \"fmt\" ) func main() { s := []string{\"a\", \"b\", \"c\", \"d\"} fmt.Println(s) }","title":"Slice Literal"},{"location":"golang/#two-ways-to-create-an-empty-or-nil-slice","text":"Initialize an empty slice with a nil value: var mySlice []int According to Golang Wiki , the former is the preferred way. Using the builtin make function to create an empty slice (non-nil): mySlice := make([]string, 0, 10) The syntax: make([]T, length, capacity) Full example: package main import ( \"fmt\" ) func main() { mySlice := make([]int, 5, 10) fmt.Printf(\"mySlice is of type %T\\nIts length is %v\\nIts capacity is %v\", mySlice, len(mySlice), cap(mySlice)) } Output: mySlice is of type []int Its length is 5 Its capacity is 10 To create a slice with a length or capacity, use make() Go Playground There's another shortcut: slice := []string{} The above slice is empty with a length of zero instead of nil(non-nil slice). Note: In most cases, empty slice and nil slice can be treated the same. In some cases, they should be treated differently, one of them is when doing JSON encoding. An empty slice will be encoded as an [] in JSON while nil slice will be encoded as null .","title":"Two ways to create an empty or nil slice"},{"location":"golang/#forrange-loop-over-a-slice","text":"The recommended way to iterate over a slice is by using a for...range loop: package main import ( \"fmt\" ) func main() { mySlice := []int{1, 2, 3, 4, 5} for i, v := range mySlice { fmt.Printf(\"Index %v has the value of %v\\n\", i, v) } } Go Playground","title":"for...range loop over a slice"},{"location":"golang/#slicing-a-slice","text":"Slicing is used to access an individual or a slice of an array. Why a slice of an array? Because slices are built on top of arrays. If you change an array, the result will reflect in the slice. To use the slice operator, two indexes are required : where the slice should start, and where the slice should stop, but not including it. Slicing from index 0 to 4 : package main import \"fmt\" func main() { underlyingArray := [5]string{\"g\", \"o\", \"l\", \"a\", \"n\", \"g\"} slice := underlyingArray[0:4] fmt.Println(slice) } Output is: [g o l a] The second index is the index the slice will stop before. Slice from index 1 till the end package main import ( \"fmt\" \"os\" ) func main() { slice := os.Args[1:] for _, v := range slice { go doSomethingAmazing(v) } } Take a list of arguments from standard input and slice from index 1 till the end. Index 0 or the name of the Go script is discarded. Slice from index 0 till index 4 If you omit the start index, 0 will be used as default: package main import ( \"fmt\" \"os\" ) func main() { underlyingArray := [5]int{1, 2, 3, 4, 5} slice := os.Args[:3] for i, v := range slice { fmt.Printf(\"Index %v has the value of %v.\", i, v) } } Output is: [1 2 3]","title":"Slicing a slice"},{"location":"golang/#appending-to-a-slice","text":"The built-in append function , appends element to the end of a slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself. The anatomy of the append function : func append(slice []Type, elems ...Type) []Type It takes a slice as the first parameter, and the second parameter can be an unlimited number of elements of the same type or another slice(unfurled with an elipsis). And it returns a slice. That's why it's recommended to store the result in the slice that we're appending values to. Example: package main import ( \"fmt\" \"bufio\" \"os\" ) func main() { var slice []string // initialize a nil slice fmt.Println(slice) // slice is nil sc := bufio.NewScanner(os.Stdin) // take parameters from standard input for sc.Scan() { // loop over lines of input slice = append(slice, sc.Text()) // append each line to the slice } fmt.Println(slice) // results } Try it: echo -e \"1\\n2\\n3\\n4\" | go run main.go","title":"Appending to a slice"},{"location":"golang/#passing-slices-to-a-variadic-function","text":"package main import ( \"fmt\" \"strings\" ) func main() { s := []string{\"Go\", \"is\", \"my\", \"favourite\", \"Programming\", \"Language\"} // creates a slice of string with 6 elements result := concatStrings(s...) // unfurl the slice with an elipsis and pass it to the function fmt.Println(result) // prints the result } func concatStrings(sentence ...string) string { var sum string for _, v := range sentence { sum += v + \" \" // concatenate all elements } sum = strings.TrimSpace(sum) // remove leading and trailing spaces return sum + \".\" // add a dot at the end } Go Playground","title":"Passing Slices to a Variadic Function"},{"location":"golang/#the-danger-of-appending-to-a-slice-that-already-has-a-length-and-a-capacity","text":"package main import ( \"fmt\" ) func main() { numbers := []int{11, 12, 13} mySlice := make([]int, 5, 10) for _, v := range numbers{ mySlice = append(mySlice, v) } fmt.Println(mySlice) } Output: [0 0 0 0 0 11 12 13] One of the ways to make use of an empty slice: package main import ( \"fmt\" ) func main() { candidates := []string{\"macOS\", \"OpenBSD\", \"Linux\"} // number of votes votes := []string{\"macOS\", \"OpenBSD\", \"Linux\", \"macOS\", \"OpenBSD\", \"macOS\"} // make an empty slice with the length of the total number of candidates counts := make([]int, len(candidates)) for _, vote := range votes { matched := false for i, candidate := range candidates { if candidate == vote { counts[i]++ matched = true } } if matched == false { candidates = append(candidates, vote) counts = append(counts, 1) } } for i, candidate := range candidates { fmt.Printf(\"%s: %d\\n\", candidate, counts[i]) } } Go Playground","title":"The danger of appending to a slice that already has a length and a capacity"},{"location":"golang/#update-entries-in-a-loop","text":"num := []int{11, 12, 13} for _, n := range num { n += 1 } fmt.Println(s) // Output: [11 12 13] The thing is, all the values is being copied one by one to a local variable n ; the slice remained intact. That's why in certain situation, we have to use pointers. To update the slice, call the slice itself: num := []int{11, 12, 13} for i := range num { // n: value is not needed s[i] =+ 1 } fmt.Println(s) // Output: [12 13 14]","title":"Update entries in a loop"},{"location":"golang/#maps","text":"","title":"Maps"},{"location":"golang/#structs","text":"https://pragmaticwebsecurity.com/cheatsheets.html","title":"Structs"},{"location":"golang/#pointer-in-a-struct","text":"https://medium.com/a-journey-with-go/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963 https://medium.com/a-journey-with-go/archive https://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/","title":"Pointer in a struct"},{"location":"grep/","text":"Grep Lines that begin with a slash and end with .js find . -type f | html-tool attribs src | grep '\\.js$' | egrep '^ */' Find dotdotslash grep -Hrn \"\\.\\./\" *","title":"Grep"},{"location":"grep/#grep","text":"","title":"Grep"},{"location":"grep/#lines-that-begin-with-a-slash-and-end-with-js","text":"find . -type f | html-tool attribs src | grep '\\.js$' | egrep '^ */'","title":"Lines that begin with a slash and end with .js"},{"location":"grep/#find-dotdotslash","text":"grep -Hrn \"\\.\\./\" *","title":"Find dotdotslash"},{"location":"idor/","text":"Authorize and Autorepeater burp plugins to find IDOR. Authorize For each request you do, it will send a equal request with something changed.. And this something is usually cookie of the session or any additional header. Example: User A will browse the webapp and we will use authorize to use cookies of user B automatically. Copy all the cookies if user 1, paste in authorize configuration In interception filter, add filters: Ignore spider request Scope items only URL Not Contains(regex): .Js|css|png|jpg|jpeg|gif|woff|BMP|ICO$ Start Authorize Browse Web using user1 and authorize will capture the request, and send the request again with modified cookies of user 2 Now you can click on each indiviual request to check modified response, if response is 403 forbidden that means user2 is not authorize to browse that webpage. 403 == Enforced == No Go So go through the webapp, browsing everything, changing profile and saving adn authorize will show if it is enforced or not. if it is not, try reading the response to check if it is vulnerable or not. Autorepeater Autorepeater is the buffed version of authorize. So suppose you have user1, user2, org1, org2... you have access to org1, but you want to check if you have access to org2, you can configure autorepeater with options of match and replace Add a Replacement: \"Replace String\" -> provide 1 org ID in Match and other org id in replace You can set highlight filter also in autorepeater. You can change content-length from application/json to application/xml in Request Header function of match and repleace.","title":"Idor"},{"location":"idor/#authorize-and-autorepeater-burp-plugins-to-find-idor","text":"","title":"Authorize and Autorepeater burp plugins to find IDOR."},{"location":"idor/#authorize","text":"For each request you do, it will send a equal request with something changed.. And this something is usually cookie of the session or any additional header. Example: User A will browse the webapp and we will use authorize to use cookies of user B automatically. Copy all the cookies if user 1, paste in authorize configuration In interception filter, add filters: Ignore spider request Scope items only URL Not Contains(regex): .Js|css|png|jpg|jpeg|gif|woff|BMP|ICO$ Start Authorize Browse Web using user1 and authorize will capture the request, and send the request again with modified cookies of user 2 Now you can click on each indiviual request to check modified response, if response is 403 forbidden that means user2 is not authorize to browse that webpage. 403 == Enforced == No Go So go through the webapp, browsing everything, changing profile and saving adn authorize will show if it is enforced or not. if it is not, try reading the response to check if it is vulnerable or not.","title":"Authorize"},{"location":"idor/#autorepeater","text":"Autorepeater is the buffed version of authorize. So suppose you have user1, user2, org1, org2... you have access to org1, but you want to check if you have access to org2, you can configure autorepeater with options of match and replace Add a Replacement: \"Replace String\" -> provide 1 org ID in Match and other org id in replace You can set highlight filter also in autorepeater. You can change content-length from application/json to application/xml in Request Header function of match and repleace.","title":"Autorepeater"},{"location":"javascript/","text":"","title":"Javascript"},{"location":"regexburp/","text":"Regex For Burp Suite search Find JWT token \\b(ey[a-z0-9+\\-\\._]+[=|==|\\s|;|\"]) Email ID \\b[\\w\\.\\!\\$\\+\\-\\/\\=\\?\\_\\~]+@[\\w]+\\.[\\w]+\\b Subdomains \\b[\\w\\.\\-\\\\\\/%\\*]*(\\.twitter)\\.(com)\\b Find IP addresses \\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b Internal IP address \\b(192|10|172)\\.(\\d\\d\\d|\\d\\d|\\d)\\.(\\d\\d\\d|\\d\\d|\\d)\\.(\\d\\d\\d|\\d\\d|\\d)\\b","title":"Regex for Burp"},{"location":"regexburp/#regex-for-burp-suite-search","text":"","title":"Regex For Burp Suite search"},{"location":"regexburp/#find-jwt-token","text":"\\b(ey[a-z0-9+\\-\\._]+[=|==|\\s|;|\"])","title":"Find JWT token"},{"location":"regexburp/#email-id","text":"\\b[\\w\\.\\!\\$\\+\\-\\/\\=\\?\\_\\~]+@[\\w]+\\.[\\w]+\\b","title":"Email ID"},{"location":"regexburp/#subdomains","text":"\\b[\\w\\.\\-\\\\\\/%\\*]*(\\.twitter)\\.(com)\\b","title":"Subdomains"},{"location":"regexburp/#find-ip-addresses","text":"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b","title":"Find IP addresses"},{"location":"regexburp/#internal-ip-address","text":"\\b(192|10|172)\\.(\\d\\d\\d|\\d\\d|\\d)\\.(\\d\\d\\d|\\d\\d|\\d)\\.(\\d\\d\\d|\\d\\d|\\d)\\b","title":"Internal IP address"},{"location":"sed/","text":"sed Remove ANSI codes/colors On Linux: ./somescript | sed -r \"s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g\" On OSX or BSD(in some cases use -E ): ./somescript | sed $'s,\\x1b\\\\[[0-9;]*[a-zA-Z],,g'","title":"Sed"},{"location":"sed/#sed","text":"","title":"sed"},{"location":"sed/#remove-ansi-codescolors","text":"On Linux: ./somescript | sed -r \"s/\\x1B\\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g\" On OSX or BSD(in some cases use -E ): ./somescript | sed $'s,\\x1b\\\\[[0-9;]*[a-zA-Z],,g'","title":"Remove ANSI codes/colors"},{"location":"sqli/","text":"SQLi This is how to find sql-Injection 100% of the time. For http://site.com/?q=HERE /?q=1 /?q=1' /?q=1\" /?q=[1] /?q[]=1 /?q=1` /?q=1\\ /?q=1/*'*/ /?q=1/*!1111'*/ /?q=1'||'asd'||' <== concat string /?q=1' or '1'='1 /?q=1 or 1=1 /?q='or''='","title":"SQLi"},{"location":"sqli/#sqli","text":"","title":"SQLi"},{"location":"sqli/#this-is-how-to-find-sql-injection-100-of-the-time-for-httpsitecomqhere","text":"/?q=1 /?q=1' /?q=1\" /?q=[1] /?q[]=1 /?q=1` /?q=1\\ /?q=1/*'*/ /?q=1/*!1111'*/ /?q=1'||'asd'||' <== concat string /?q=1' or '1'='1 /?q=1 or 1=1 /?q='or''='","title":"This is how to find sql-Injection 100% of the time. For http://site.com/?q=HERE"},{"location":"test_for_passwd_reset/","text":"Testing Password Reset Functionalities Guess/brute force password before clicking on reset link Sometimes the password is reset to a guessable value (birthday date, username+id, etc) even if the reset procedure is not completed (reset link by email, otp, etc).. So you can just click on reset password and then guess/brute that value. Include your mail as a second parameter (you might receive the reset link) POST /reset [...] email=victim@tld.xyz&email=hacker@tld.xyz Brute force reset token if it a numeric. You can use IP Rotator on Burpsuite to bypass rate limit in case it's IP based POST /reset [...] email=victim@tld.xyz&code=$BRUTE$ Try to use your reset token on target's account POST /reset [...] email=victim@tld.xyz&code=$YOUR-TOKEN$ Host Header injection - change website.com to hacker.com (victim might receive the reset link with your host instead of the original website's) POST /reset Host hacker.com [...] If successful, your POC can contain a crafted link send to the victim, and your host is hosting a fake form that ask the victim for sensitive information. Try to figure out how the tokens are generated Generated based on TimeStamp Generated based on the ID of the user Generated based on the email of the user Email delimited with a comma POST /reset [...] email=victim@tld.xyz,attacker@mail.net OR POST /reset [...] email=victim@tld.xyz&bccattacker@email.com Password reset token leakage via referer - POC on Hackerone Request for password reset Now check your email you will get your password reset link Now just copy the link and open you browser in private mode and paste the link (try disabling all your addons) Don't change the password yet. Click any external links like social media links, etc. I have clicked on Twitter Capture the request in burp. You will find reset token in referer header. Reset password - before clicking the link change your account's email Issue the reset. But before using the token(from your email inbox), change your email on your account to the one of the victim. See if the reset tokens still works(use your imagination) Intercept reset request in burp and add more emails Reset password. Click on reset link. Intercept in burp Try adding company emails, or victim email OR add a new field \"password\"\"example123\" or \"pass\":\"example123\" you may end up resetting a user's password. still nothing ?? Try to figure out what encoding is being used for password reset (eg. json). Search for disclosed reports on similar technology/keywords and go from there. don't know how to describe this Completely remove the token change it to 00000000... use null/nil value try expired token try an array of old tokens look for race conditions change 1 char at the begin/end to see if the token is evaluated use unicode char jutzu to spoof email address try victim@email.com&attacker@email.com use %20 or | as separators try to register the same mail with different TLD (.eu,.net etc) don't add the domain kavish@ try sqli bypass and wildcard or, %, * request smuggler? change request method (get, put, post etc) and/or content type (xml<>json) match bad response and replace with good one use super long string More Tips in JSON array {\"email\":[\"victim@mail.tld\",\"attacker@mail.tld\"]} Try to add X-Forwarded-Hostattacker.com Find emails https://hunter.io","title":"Testing for Password Reset Functionalities"},{"location":"test_for_passwd_reset/#testing-password-reset-functionalities","text":"","title":"Testing Password Reset Functionalities"},{"location":"test_for_passwd_reset/#guessbrute-force-password-before-clicking-on-reset-link","text":"Sometimes the password is reset to a guessable value (birthday date, username+id, etc) even if the reset procedure is not completed (reset link by email, otp, etc).. So you can just click on reset password and then guess/brute that value.","title":"Guess/brute force password before clicking on reset link"},{"location":"test_for_passwd_reset/#include-your-mail-as-a-second-parameter-you-might-receive-the-reset-link","text":"POST /reset [...] email=victim@tld.xyz&email=hacker@tld.xyz","title":"Include your mail as a second parameter (you might receive the reset link)"},{"location":"test_for_passwd_reset/#brute-force-reset-token-if-it-a-numeric-you-can-use-ip-rotator-on-burpsuite-to-bypass-rate-limit-in-case-its-ip-based","text":"POST /reset [...] email=victim@tld.xyz&code=$BRUTE$","title":"Brute force reset token if it a numeric. You can use IP Rotator on Burpsuite to bypass rate limit in case it's IP based"},{"location":"test_for_passwd_reset/#try-to-use-your-reset-token-on-targets-account","text":"POST /reset [...] email=victim@tld.xyz&code=$YOUR-TOKEN$","title":"Try to use your reset token on target's account"},{"location":"test_for_passwd_reset/#host-header-injection-change-websitecom-to-hackercom-victim-might-receive-the-reset-link-with-your-host-instead-of-the-original-websites","text":"POST /reset Host hacker.com [...] If successful, your POC can contain a crafted link send to the victim, and your host is hosting a fake form that ask the victim for sensitive information.","title":"Host Header injection - change website.com to hacker.com (victim might receive the reset link with your host instead of the original website's)"},{"location":"test_for_passwd_reset/#try-to-figure-out-how-the-tokens-are-generated","text":"Generated based on TimeStamp Generated based on the ID of the user Generated based on the email of the user","title":"Try to figure out how the tokens are generated"},{"location":"test_for_passwd_reset/#email-delimited-with-a-comma","text":"POST /reset [...] email=victim@tld.xyz,attacker@mail.net OR POST /reset [...] email=victim@tld.xyz&bccattacker@email.com","title":"Email delimited with a comma"},{"location":"test_for_passwd_reset/#password-reset-token-leakage-via-referer-poc-on-hackerone","text":"Request for password reset Now check your email you will get your password reset link Now just copy the link and open you browser in private mode and paste the link (try disabling all your addons) Don't change the password yet. Click any external links like social media links, etc. I have clicked on Twitter Capture the request in burp. You will find reset token in referer header.","title":"Password reset token leakage via referer - POC on Hackerone"},{"location":"test_for_passwd_reset/#reset-password-before-clicking-the-link-change-your-accounts-email","text":"Issue the reset. But before using the token(from your email inbox), change your email on your account to the one of the victim. See if the reset tokens still works(use your imagination)","title":"Reset password - before clicking the link change your account's email"},{"location":"test_for_passwd_reset/#intercept-reset-request-in-burp-and-add-more-emails","text":"Reset password. Click on reset link. Intercept in burp Try adding company emails, or victim email OR add a new field \"password\"\"example123\" or \"pass\":\"example123\" you may end up resetting a user's password.","title":"Intercept reset request in burp and add more emails"},{"location":"test_for_passwd_reset/#still-nothing","text":"Try to figure out what encoding is being used for password reset (eg. json). Search for disclosed reports on similar technology/keywords and go from there.","title":"still nothing ??"},{"location":"test_for_passwd_reset/#dont-know-how-to-describe-this","text":"Completely remove the token change it to 00000000... use null/nil value try expired token try an array of old tokens look for race conditions change 1 char at the begin/end to see if the token is evaluated use unicode char jutzu to spoof email address try victim@email.com&attacker@email.com use %20 or | as separators try to register the same mail with different TLD (.eu,.net etc) don't add the domain kavish@ try sqli bypass and wildcard or, %, * request smuggler? change request method (get, put, post etc) and/or content type (xml<>json) match bad response and replace with good one use super long string","title":"don't know how to describe this"},{"location":"test_for_passwd_reset/#more-tips","text":"in JSON array {\"email\":[\"victim@mail.tld\",\"attacker@mail.tld\"]} Try to add X-Forwarded-Hostattacker.com Find emails https://hunter.io","title":"More Tips"},{"location":"vim/","text":"Vim Editor Vimrc let mapleader = \"\\<space>\" syntax on let g:pymode_python = 'python3' \" sort the buffer for unique lines nmap <Leader>s :%!sort -u --version-sort<CR> \" Base64 decode word under cursor nmap <Leader>b :!echo <C-R><C-W> \\| base64 -D<CR> set hlsearch Open file under cursor in a new tab: # Press CTRL+'w' then 'f' <C-W>f Execute shell command on the data that is in the vim buffer or file :%! sort -u Run shell commands and put the output in the vim buffer or file Hit ! twice, and you'll get a vim prompt in the bottom left corner that looks like this: :.! Then just type your command and press enter: :.!whoami In fish shell, make a universal variable (or else vim won't work properly) set -U EDITOR vim Pipe data into a vim buffer: grep -Hnri * | vim - Sort the fifth column # to look at content size :%!find . -type f -exec ls -l {} \\; # sort based on fifth column :%! sort -k5,5 -n","title":"Vim"},{"location":"vim/#vim-editor","text":"","title":"Vim Editor"},{"location":"vim/#vimrc","text":"let mapleader = \"\\<space>\" syntax on let g:pymode_python = 'python3' \" sort the buffer for unique lines nmap <Leader>s :%!sort -u --version-sort<CR> \" Base64 decode word under cursor nmap <Leader>b :!echo <C-R><C-W> \\| base64 -D<CR> set hlsearch","title":"Vimrc"},{"location":"vim/#open-file-under-cursor-in-a-new-tab","text":"# Press CTRL+'w' then 'f' <C-W>f","title":"Open file under cursor in a new tab:"},{"location":"vim/#execute-shell-command-on-the-data-that-is-in-the-vim-buffer-or-file","text":":%! sort -u","title":"Execute shell command on the data that is in the vim buffer or file"},{"location":"vim/#run-shell-commands-and-put-the-output-in-the-vim-buffer-or-file","text":"Hit ! twice, and you'll get a vim prompt in the bottom left corner that looks like this: :.! Then just type your command and press enter: :.!whoami","title":"Run shell commands and put the output in the vim buffer or file"},{"location":"vim/#in-fish-shell-make-a-universal-variableor-else-vim-wont-work-properly","text":"set -U EDITOR vim","title":"In fish shell, make a universal variable(or else vim won't work properly)"},{"location":"vim/#pipe-data-into-a-vim-buffer","text":"grep -Hnri * | vim -","title":"Pipe data into a vim buffer:"},{"location":"vim/#sort-the-fifth-column","text":"# to look at content size :%!find . -type f -exec ls -l {} \\; # sort based on fifth column :%! sort -k5,5 -n","title":"Sort the fifth column"},{"location":"vim_tutorial/","text":"USing Assetfinder to get subdomains # assetfinder --subs-only uber.com > domains Know which are running webservers, it checks which are having http and https server listening # cat domains | httpprobe | tee hosts /* Use \"tee -a\" to append */ Using meg meg -d 1000 -c 10 / Above command will make an output direcotry called \"out\" and inside it, it will make individual directory for each subdomain. Each subdomain directory will contain a file for both http and https request. You also get a index.html file which will show the path with response code, so you can easily grep for 200 status code and get accepted urls. # grep -Hnri uber internal * | vim - you can save this result in a file \":w results\" Running commands in the vim :%!sort -u (% means current file, ! to run shell command) :%grep -v Content-Secu awk - text processing command :%!awk -F';' ;{print $3}' /* -F = Field Separator, '{print $X}' = print X field */ Ctrl+v/right click to put vim in visual mode and then you can use arrow keys to do vertical/horizontal selection and then hit 'X' to delete them Shift+a to go to the end of the line and delete a single item and then press dot(.) and vim will repeat the last thing(instruction) :/.$ (\\ -> don't treat as an expression, $= End of the line) Search and replace :%s/\\<search_item>/\\<replace> :%s/// (// -> it search for whatever you last searched for) xargs xargs takes multiple lines of input and runs a command on every line of it. :%!xargs -n1 -I{} sh -c 'echo {} | base64 -d' (n1 -> give 1 input at a time, -I{} is a placeholder of input, sh -c -> to pass the command to shell ) html-tool from tomnomnom # find . -type f | html-tool attribs src (this will give all of the src attributes from all of the files) # find . -type f | html-tool tags title | vim - ( give the title tag from all of the files) :tabnew | read !grep -HNR 'self' (grep for whatever under the cursor and then open the result in a new buffer in a new tab so it shows up at a few places then ctrl+w+g+shift+f and this will take me straight to the line where that title exists. gf gf urls | grep yahoo.com | vi - (finds every url) unfurl from tomnomnom (its a great tool to make wordlist using keys and values for fuzzing) :%!unfurl -u paths (gives the uniques paths from all the urls) :%!unfurl -u keys (to get query strings) param miner extension - finds hidden parameters, above will be a good wordlist","title":"Vim tutorial"},{"location":"vim_tutorial/#using-assetfinder-to-get-subdomains","text":"# assetfinder --subs-only uber.com > domains","title":"USing Assetfinder to get subdomains"},{"location":"vim_tutorial/#know-which-are-running-webservers-it-checks-which-are-having-http-and-https-server-listening","text":"# cat domains | httpprobe | tee hosts /* Use \"tee -a\" to append */","title":"Know which are running webservers, it checks which are having http and https server listening"},{"location":"vim_tutorial/#using-meg","text":"meg -d 1000 -c 10 / Above command will make an output direcotry called \"out\" and inside it, it will make individual directory for each subdomain. Each subdomain directory will contain a file for both http and https request. You also get a index.html file which will show the path with response code, so you can easily grep for 200 status code and get accepted urls. # grep -Hnri uber internal * | vim - you can save this result in a file \":w results\"","title":"Using meg"},{"location":"vim_tutorial/#running-commands-in-the-vim","text":":%!sort -u (% means current file, ! to run shell command) :%grep -v Content-Secu","title":"Running commands in the vim"},{"location":"vim_tutorial/#awk-text-processing-command","text":":%!awk -F';' ;{print $3}' /* -F = Field Separator, '{print $X}' = print X field */ Ctrl+v/right click to put vim in visual mode and then you can use arrow keys to do vertical/horizontal selection and then hit 'X' to delete them Shift+a to go to the end of the line and delete a single item and then press dot(.) and vim will repeat the last thing(instruction) :/.$ (\\ -> don't treat as an expression, $= End of the line)","title":"awk - text processing command"},{"location":"vim_tutorial/#search-and-replace","text":":%s/\\<search_item>/\\<replace> :%s/// (// -> it search for whatever you last searched for)","title":"Search and replace"},{"location":"vim_tutorial/#xargs","text":"xargs takes multiple lines of input and runs a command on every line of it. :%!xargs -n1 -I{} sh -c 'echo {} | base64 -d' (n1 -> give 1 input at a time, -I{} is a placeholder of input, sh -c -> to pass the command to shell )","title":"xargs"},{"location":"vim_tutorial/#html-tool-from-tomnomnom","text":"# find . -type f | html-tool attribs src (this will give all of the src attributes from all of the files) # find . -type f | html-tool tags title | vim - ( give the title tag from all of the files) :tabnew | read !grep -HNR 'self' (grep for whatever under the cursor and then open the result in a new buffer in a new tab so it shows up at a few places then ctrl+w+g+shift+f and this will take me straight to the line where that title exists.","title":"html-tool from tomnomnom"},{"location":"vim_tutorial/#gf","text":"gf urls | grep yahoo.com | vi - (finds every url)","title":"gf"},{"location":"vim_tutorial/#unfurl-from-tomnomnom-its-a-great-tool-to-make-wordlist-using-keys-and-values-for-fuzzing","text":":%!unfurl -u paths (gives the uniques paths from all the urls) :%!unfurl -u keys (to get query strings) param miner extension - finds hidden parameters, above will be a good wordlist","title":"unfurl from tomnomnom                     (its a great tool to make wordlist using keys and values for fuzzing)"},{"location":"xargs/","text":"xargs Decode base64 inside vim Parse lines of data to xargs ( -d on linux): :%! xargs -n1 -I{} sh -c 'echo {} | base64 -D' Note: Omit sh -c if you're using bash","title":"Xargs"},{"location":"xargs/#xargs","text":"","title":"xargs"},{"location":"xargs/#decode-base64-inside-vim","text":"Parse lines of data to xargs ( -d on linux): :%! xargs -n1 -I{} sh -c 'echo {} | base64 -D' Note: Omit sh -c if you're using bash","title":"Decode base64 inside vim"},{"location":"xss/","text":"XSS For the advanced stuff, you're going to want to look into filter evasion techniques. Know what encodings work natively in what spaces (text space, attribute space, URI space, script space). HTML encoded entities work in attribute space, for example. Know what encodings to try to get the server to decode. Double Nibble Hex encoding, for example. Have a solid understanding of SOP, CSP, and CORS. Learn the sources and sinks (ins and outs) of DOM XSS. XSS is nothing but HTML and javascript. If you don't know how those work, your potential will be very limited. Practice The unescape() room - Filter evasion practice alf.nu's XSS Game - Filter evasion practice prompt.ml's XSS Game - Filter evasion practice pwnfunction's XSS Game - Filter evasion practice Google Firing Range - Real world scenarios. Cheatsheet Portswigger Cheatsheet Learn Intigriti Portswigger Labs Same Origin Policy Javascript Escapes Utilities XSS Hunter - Good for Blind XSS Findom-XSS Prevent XSS Is replacing special characters enough?","title":"XSS"},{"location":"xss/#xss","text":"For the advanced stuff, you're going to want to look into filter evasion techniques. Know what encodings work natively in what spaces (text space, attribute space, URI space, script space). HTML encoded entities work in attribute space, for example. Know what encodings to try to get the server to decode. Double Nibble Hex encoding, for example. Have a solid understanding of SOP, CSP, and CORS. Learn the sources and sinks (ins and outs) of DOM XSS. XSS is nothing but HTML and javascript. If you don't know how those work, your potential will be very limited.","title":"XSS"},{"location":"xss/#practice","text":"The unescape() room - Filter evasion practice alf.nu's XSS Game - Filter evasion practice prompt.ml's XSS Game - Filter evasion practice pwnfunction's XSS Game - Filter evasion practice Google Firing Range - Real world scenarios.","title":"Practice"},{"location":"xss/#cheatsheet","text":"Portswigger Cheatsheet","title":"Cheatsheet"},{"location":"xss/#learn","text":"Intigriti Portswigger Labs Same Origin Policy Javascript Escapes","title":"Learn"},{"location":"xss/#utilities","text":"XSS Hunter - Good for Blind XSS Findom-XSS","title":"Utilities"},{"location":"xss/#prevent-xss","text":"Is replacing special characters enough?","title":"Prevent XSS"}]}