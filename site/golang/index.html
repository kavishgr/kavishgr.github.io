<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Golang - Kavish Gour - Notes</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Golang";
    var mkdocs_page_input_path = "golang.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Kavish Gour - Notes</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../bash_alias/">Bash Alias</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Golang</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#pointers">Pointers</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#dereferencing-a-pointer">Dereferencing a Pointer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#a-pointer-as-an-argument-in-a-function">A Pointer as an Argument in a Function</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#assignment-operators">Assignment Operators</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#loops">Loops</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_1"></a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#init-condition-and-post-optional">Init, Condition, and Post (optional)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#while-loop">While loop</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#infinite-loop">Infinite loop</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#forrange-loop">For...range loop</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#continue-and-break">Continue and Break</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#slice">Slice</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#slice-literal">Slice Literal</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#two-ways-to-create-an-empty-or-nil-slice">Two ways to create an empty or nil slice</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#forrange-loop-over-a-slice">for...range loop over a slice</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#slicing-a-slice">Slicing a slice</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#appending-to-a-slice">Appending to a slice</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#passing-slices-to-a-variadic-function">Passing Slices to a Variadic Function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#the-danger-of-appending-to-a-slice-that-already-has-a-length-and-a-capacity">The danger of appending to a slice that already has a length and a capacity</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#update-entries-in-a-loop">Update entries in a loop</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#remove-duplicate-values-from-a-slice">remove duplicate values from a slice</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#maps">Maps</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#create-an-empty-map-and-a-map-literal">Create an empty map, and a map literal</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#add-new-key-value-pair">Add new key-value pair</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#update-value">Update value</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#iterating-over-a-map">Iterating over a map</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#verify-if-a-key-exists-or-not">Verify if a key exists or not</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#delete-a-key">Delete a key</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#maps-cant-contain-duplicate-keys">Maps can't contain duplicate keys</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#incrementing-values">Incrementing values</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#diff-maps-for-duplicate-values">Diff maps for duplicate values</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#map-as-a-function-argument">Map as a function argument</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#copy-a-map">Copy a map</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#define-your-own-type">Define your own type</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#structs">Structs</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#define-a-struct">Define a struct</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#define-a-struct-type">Define a struct type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#struct-defined-type-as-a-function-parameter">Struct defined type as a function parameter</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#try">Try</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#use-a-pointer-to-modify-a-struct-with-a-function">Use a pointer to modify a struct with a function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#return-a-pointer-to-a-struct">Return a pointer to a struct</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#embedding-anonymous-struct-fields">Embedding Anonymous Struct Fields</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#methods">Methods</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#encapsulation">Encapsulation</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#package-visibility">Package Visibility</a>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../grep/">Grep</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../sed/">Sed</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../vim/">Vim</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../xargs/">Xargs</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Kavish Gour - Notes</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Golang</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="golang">Golang</h1>
<h2 id="pointers">Pointers</h2>
<p>A Pointer is a variable that stores the memory address of another variable. A variable can contain any type of values, but when a variable has a memory address as its value, it's called a pointer.</p>
<p>To create a pointer, an <code>&amp;</code> operator is used to retrieve the memory address of a variable:</p>
<pre><code>var x = 101 // an integer as its value
var ptr = &amp;x  // get the memory address of x and stores it in a variable called ptr
</code></pre>

<p>The <code>&amp;x</code> retrieves the memory address of x and stores it in <code>ptr</code>. A complete example:</p>
<pre><code>package main

import &quot;fmt&quot;

var p = fmt.Println

func main() {
    var x = 101
    var ptr = &amp;x

    p(&quot;The memory address of x:&quot;, &amp;x)
    p(&quot;The memory address of ptr:&quot;, &amp;ptr)
    p(&quot;The value of ptr:&quot;, ptr)
}
</code></pre>

<pre><code>// output
The memory address of x:     0xc0000b4020
The memory address of ptr:   0xc0000b6018
The value of ptr:            0xc0000b4020
</code></pre>

<p><a href="https://play.golang.org/p/UoAJkaMtucM">Go Playground</a></p>
<p>Every variable represents a memory address pointing to a value like so:</p>
<pre><code>0xc0000b6018  = 101
</code></pre>

<p>A variable pointing to a memory address of another variable is called a pointer.</p>
<h3 id="dereferencing-a-pointer">Dereferencing a Pointer</h3>
<p>Dereferencing is used to access or manipulate data contained in a memory location pointed to by a pointer variable or simply pointer.</p>
<p>To access or manipulate the data of a pointer or to dereference a pointer, an <code>*</code> operator is used in front of the pointer variable:</p>
<pre><code>package main

import &quot;fmt&quot;

var p = fmt.Println

func main() {
    var x = &quot;Having fun with pointers&quot; // declare a varible with data of type string
    var ptr = &amp;x // store the memory address of variable, hence a pointer
    p(*ptr) // print the value of the pointer
    *ptr = &quot;Still having fun with pointers&quot; // dereference the pointer with new data
    p(x) // print the new data
}
</code></pre>

<p><a href="https://play.golang.org/p/e6v88j4E9cZ">Go Playground</a></p>
<h3 id="a-pointer-as-an-argument-in-a-function">A Pointer as an Argument in a Function</h3>
<p>To define a function() that takes a memory address as an argument or simply a pointer, <strong><code>*T</code></strong> is used as the type. In this case, <code>*int</code> which stands for a pointer to an int, or a memory address whose value is an int.</p>
<p>You give the function() a memory address by prepending the variable with an <code>&amp;</code> operator. Inside the function, an <code>*</code> is used to access the value, hence dereferencing a pointer.</p>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
)

func zero(ptr *int){ 

    // *int means: I need a memory address that points to data of type int

    // behind the scene, ptr will point to a memory address that looks like this (in hexadecimal): ptr = 0xc00002c008 

    // on the next line, the asterisk '*' is used again(now in front of the pointer variable)
    // to dereference the pointer, hence access/manipulate the value stored in that particular 
    // memory address
    // behind the scene =&gt; replace the current value of 0xc00002c008 or ptr with 0

    *ptr = 0 // store 0 in the memory address *ptr is refering to


    // if I write: ptr = 0 
    // the go compiler will return an error saying: cannot use 0 (type int) as type *int in assignment
    // because ptr is like: var ptr *int
    // ptr will only accept or store a memory address as its value
    // 
    // you can't just assign a value in it
    // you have to dereference it first
}


func main() {
    x := 5  
    zero(&amp;x)    // the &amp; operator finds the address of variable x   
    fmt.Println(x)
}
</code></pre>

<p><a href="https://play.golang.org/p/DhjG6aC-j-M">Go Playground</a></p>
<h2 id="assignment-operators">Assignment Operators</h2>
<h2 id="loops">Loops</h2>
<p>The beauty of Go's <code>For</code> loop is that it merges many modern style of looping into one <a href="https://golang.org/ref/spec#Keywords">keyword</a>. Loops <strong>always</strong> begin with the <code>for</code> keyword.</p>
<h3 id="_1"></h3>
<h3 id="init-condition-and-post-optional">Init, Condition, and Post (optional)</h3>
<pre><code class="golang">func main() {
    for i := 0; i &lt;=3; i++{
        fmt.Println(i)
    }
}
</code></pre>

<p><strong>Initialize</strong> a statement - <code>i := 0</code>
<strong>Condition</strong> that determine if the loop has to continue or stop - <code>i &lt;= 3</code>
<strong>Post statement</strong> runs if condition is true - <code>i++</code> (including the loop block {})</p>
<p>The variable <code>i</code> is only visible in the loop block.</p>
<h3 id="while-loop">While loop</h3>
<p>To construct a <code>while loop</code>, omit the init and post statement:</p>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
)

func main() {
    i := 0 // declared outside of loop block
    fmt.Println(&quot;i is&quot;, i)
    for i &lt; 5{ // while true, keep looping
        i++
        fmt.Println(&quot;Now i is&quot;, i)
    } // end of loop block
    fmt.Println()
    fmt.Println(&quot;Final is&quot;, i)

}
</code></pre>

<h3 id="infinite-loop">Infinite loop</h3>
<h3 id="forrange-loop">For...range loop</h3>
<h3 id="continue-and-break">Continue and Break</h3>
<h2 id="slice">Slice</h2>
<p>A slice is a dynamic container that hold elements of the same type. It's build on top of an array.</p>
<p>https://play.golang.org/p/GJrrw1BYo_O</p>
<h3 id="slice-literal">Slice Literal</h3>
<p>A slice literal is used when you already know what values it will contain:</p>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
)

func main() {

    s := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
    fmt.Println(s)
}
</code></pre>

<h3 id="two-ways-to-create-an-empty-or-nil-slice">Two ways to create an empty or nil slice</h3>
<ul>
<li>Initialize an empty slice with a nil value:</li>
</ul>
<pre><code class="golang">var mySlice []int
</code></pre>

<p>According to <a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices">Golang Wiki</a>, the former is the preferred way.</p>
<ul>
<li>Using the builtin <code>make</code> function to create an empty slice (non-nil):</li>
</ul>
<pre><code class="golang">mySlice := make([]string, 0, 10)
</code></pre>

<p>The syntax: <code>make([]T, length, capacity)</code></p>
<p>Full example:</p>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
)

func main() {
    mySlice := make([]int, 5, 10)
    fmt.Printf(&quot;mySlice is of type %T\nIts length is %v\nIts capacity is %v&quot;, mySlice, len(mySlice), cap(mySlice))
}
</code></pre>

<p>Output:</p>
<pre><code>mySlice is of type []int
Its length is 5
Its capacity is 10
</code></pre>

<p>To create a slice with a length or capacity, use <code>make()</code></p>
<p><a href="https://play.golang.org/p/049NI7H1ROA">Go Playground</a></p>
<p>There's another shortcut: </p>
<pre><code class="golang">slice := []string{}
</code></pre>

<p>The above slice is empty with a length of zero instead of nil(non-nil slice).</p>
<p><strong>Note:</strong> In most cases, empty slice and nil slice can be treated the same. In some cases, they should be treated differently, one of them is when doing JSON encoding.
An empty slice will be encoded as an <code>[]</code> in JSON while nil slice will be encoded as <code>null</code>.</p>
<h3 id="forrange-loop-over-a-slice">for...range loop over a slice</h3>
<p>The recommended way to iterate over a slice is by using a for...range loop:</p>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
)

func main() {
    mySlice := []int{1, 2, 3, 4, 5}

    for i, v := range mySlice {
        fmt.Printf(&quot;Index %v has the value of %v\n&quot;, i, v)  
    }   
}
</code></pre>

<p><a href="https://play.golang.org/p/t-jsaVKQKYD">Go Playground</a></p>
<h3 id="slicing-a-slice">Slicing a slice</h3>
<p>Slicing is used to access an individual or a slice of an array. <strong>Why a slice of an array?</strong> Because slices are built on top of arrays. <strong>If you change an array, the result will reflect in the slice.</strong></p>
<p><strong>To use the slice operator, two indexes are required</strong>: where the slice should start, and where the slice should stop, but not including it.</p>
<ul>
<li><strong>Slicing from index 0 to 4</strong>:</li>
</ul>
<pre><code class="golang">package main

import &quot;fmt&quot;

func main() {
    underlyingArray := [5]string{&quot;g&quot;, &quot;o&quot;, &quot;l&quot;, &quot;a&quot;, &quot;n&quot;, &quot;g&quot;}
    slice := underlyingArray[0:4]
    fmt.Println(slice)
}
</code></pre>

<p>Output is:</p>
<pre><code>[g o l a]
</code></pre>

<p>The second index is the index the slice will stop before.</p>
<ul>
<li><strong>Slice from index 1 till the end</strong></li>
</ul>
<pre><code class="golang">package main

import (
        &quot;fmt&quot;
        &quot;os&quot;
)

func main() {
    slice := os.Args[1:]
    for _, v := range slice {
        go doSomethingAmazing(v)
    }
}
</code></pre>

<p>Take a list of arguments from standard input and slice from index 1 till the end. Index 0 or the name of the Go script is discarded.</p>
<ul>
<li><strong>Slice from index 0 till index 4</strong></li>
</ul>
<p>If you omit the start index, 0 will be used as default:</p>
<pre><code class="golang">package main

import (
        &quot;fmt&quot;
        &quot;os&quot;
)

func main() {
    underlyingArray := [5]int{1, 2, 3, 4, 5}
    slice := os.Args[:3]
    for i, v := range slice {
        fmt.Printf(&quot;Index %v has the value of %v.&quot;, i, v)
    }
}
</code></pre>

<p>Output is:</p>
<pre><code>[1 2 3]
</code></pre>

<h3 id="appending-to-a-slice">Appending to a slice</h3>
<p>The <a href="https://golang.org/pkg/builtin/#append">built-in append function</a>, appends element to the end of a slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself.</p>
<p><strong>The anatomy of the append function</strong>:</p>
<pre><code class="golang">func append(slice []Type, elems ...Type) []Type
</code></pre>

<p>It takes a slice as the first parameter, and the second parameter can be an unlimited number of elements of the same type or another slice(unfurled with an elipsis). And it returns a slice. That's why it's recommended to store the result in the slice that we're appending values to.</p>
<p>Example:</p>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
    &quot;bufio&quot;
    &quot;os&quot;
)

func main() {
    var slice []string // initialize a nil slice
    fmt.Println(slice)  // slice is nil
    sc := bufio.NewScanner(os.Stdin) // take parameters from standard input
    for sc.Scan() {                  // loop over lines of input
        slice = append(slice, sc.Text()) // append each line to the slice
    }
    fmt.Println(slice) // results
}
</code></pre>

<p>Try it:</p>
<pre><code class="bash">echo -e &quot;1\n2\n3\n4&quot; | go run main.go
</code></pre>

<h3 id="passing-slices-to-a-variadic-function">Passing Slices to a Variadic Function</h3>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func main() {
    s := []string{&quot;Go&quot;, &quot;is&quot;, &quot;my&quot;, &quot;favourite&quot;, &quot;Programming&quot;, &quot;Language&quot;} // creates a slice of string with 6 elements
    result := concatStrings(s...) // unfurl the slice with an elipsis and pass it to the function
    fmt.Println(result) // prints the result

}

func concatStrings(sentence ...string) string { 
    var sum string
    for _, v := range sentence {
        sum += v + &quot; &quot; // concatenate all elements
    }
    sum =  strings.TrimSpace(sum) // remove leading and trailing spaces
    return sum + &quot;.&quot; // add a dot at the end
}
</code></pre>

<p><a href="https://play.golang.org/p/U8SGRB2RO2q">Go Playground</a></p>
<h3 id="the-danger-of-appending-to-a-slice-that-already-has-a-length-and-a-capacity">The danger of appending to a slice that already has a length and a capacity</h3>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
)

func main() {
    numbers := []int{11, 12, 13}
    mySlice := make([]int, 5, 10)

    for _, v := range numbers{
        mySlice = append(mySlice, v)
    }
    fmt.Println(mySlice)
}
</code></pre>

<p>Output:</p>
<pre><code class="golang">[0 0 0 0 0 11 12 13]
</code></pre>

<p>One of the ways to make use of an empty slice:</p>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
)

func main() {
    candidates := []string{&quot;macOS&quot;, &quot;OpenBSD&quot;, &quot;Linux&quot;}
    // number of votes                                                 
    votes := []string{&quot;macOS&quot;, &quot;OpenBSD&quot;, &quot;Linux&quot;, &quot;macOS&quot;, &quot;OpenBSD&quot;, &quot;macOS&quot;}
    // make an empty slice with the length of  the total number of candidates 
    counts := make([]int, len(candidates)) 

    for _, vote := range votes {
        matched := false
        for i, candidate := range candidates {
            if candidate == vote {
                counts[i]++
                matched = true
            }
        }
        if matched == false {
            candidates = append(candidates, vote)
            counts = append(counts, 1)
        }
    }
    for i, candidate := range candidates {
        fmt.Printf(&quot;%s: %d\n&quot;, candidate, counts[i])
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/9QncTu0JVhR">Go Playground</a></p>
<h3 id="update-entries-in-a-loop">Update entries in a loop</h3>
<pre><code class="golang">num := []int{11, 12, 13}
for _, n := range num {
    n += 1
}
fmt.Println(s)
// Output: [11 12 13]
</code></pre>

<p>The thing is, all the values is being <strong>copied one by one</strong> to <strong>a local variable n</strong>; the slice remained intact. That's why in certain situation, we have to use pointers.</p>
<p>To update the slice, call the slice itself:</p>
<pre><code class="golang">num := []int{11, 12, 13}
for i := range num { // n: value is not needed
    s[i] =+ 1
}
fmt.Println(s)
// Output: [12 13 14]
</code></pre>

<h3 id="remove-duplicate-values-from-a-slice">remove duplicate values from a slice</h3>
<p>https://www.golangprograms.com/remove-duplicate-values-from-slice.html</p>
<h2 id="maps">Maps</h2>
<p>A map is an unordered list of key-value pairs. It's a dynamic data structure. It can't contain dupicate keys.</p>
<h3 id="create-an-empty-map-and-a-map-literal">Create an empty map, and a map literal</h3>
<ul>
<li>Empty map:</li>
</ul>
<p><strong>Syntax</strong>: <code>make(map[KeyType]ValueType)</code></p>
<pre><code class="go">m := make(map[string]string)

//OR

var m = make(map[string]string)
</code></pre>

<ul>
<li>Map literal(<strong>last trailing comma is necessary</strong>):</li>
</ul>
<pre><code class="go">m := map[string]int{
    &quot;First&quot;: 100,
    &quot;Second&quot;: 80, // comma is necessary
} 
</code></pre>

<h3 id="add-new-key-value-pair">Add new key-value pair</h3>
<p><strong>Syntax</strong>: <code>m[key] = value</code></p>
<pre><code class="go">func main() {

    m := map[string]int{
        &quot;First&quot;:  100,
        &quot;Second&quot;: 80,
    }

    fmt.Println(m)

    m[&quot;Third&quot;] = 70

    fmt.Println(m)

}
</code></pre>

<p><a href="https://play.golang.org/p/8RRm9AxjkhI">Go Playground</a></p>
<h3 id="update-value">Update value</h3>
<pre><code class="go">func main() {

    m := map[string]int{
        &quot;First&quot;:  100,
        &quot;Second&quot;: 80,
    }

    m[&quot;First&quot;] = 0
    m[&quot;Second&quot;] = 0

    fmt.Println(m)
}

</code></pre>

<p><a href="https://play.golang.org/p/Zh9sL2k07oS">Go Playground</a></p>
<h3 id="iterating-over-a-map">Iterating over a map</h3>
<pre><code class="go">func main() {

    m := map[string]int{
        &quot;First&quot;:  100,
        &quot;Second&quot;: 80,
    }

    for key, value := range m {
        fmt.Printf(&quot;Key:%v\tValue:%v\n&quot;, key, value)
    }
}

</code></pre>

<p><a href="https://play.golang.org/p/2jdjZ8tuIry">Go Playground</a></p>
<h3 id="verify-if-a-key-exists-or-not">Verify if a key exists or not</h3>
<p>A map key can also return a second value, a Boolean. If the key exists, it will return true, or false if the key is not present.</p>
<pre><code class="go">func main() {

    listOfName := []string{&quot;John&quot;, &quot;Mary&quot;, &quot;Jane&quot;}
    for _, name := range listOfName{
        grades(name)
    }
}

func grades(name string) {
    students := map[string]float64{
        &quot;John&quot;: 91.7,
        &quot;Jane&quot;: 92,
    }
    grade, ok := students[name] // the second value
    if !ok { // if false OR if not true
        fmt.Printf(&quot;No grade for %v!!!\n&quot;, name)
    } else if grade &lt; 60 {
        fmt.Printf(&quot;%v is failing.\n&quot;, name)
    } else {
        fmt.Printf(&quot;%v is doing well.\n&quot;, name)
    }
}

</code></pre>

<p><a href="https://play.golang.org/p/C3AL-2-ZToT">Go Playground</a></p>
<h3 id="delete-a-key">Delete a key</h3>
<p>The built-in <code>delete()</code> function will remove the key and its value.</p>
<p><strong>Syntax</strong>: <code>delete(map, "KEY")</code></p>
<pre><code class="go">func main() {

    m := map[string]string{
        &quot;Team A&quot;: &quot;Champions&quot;,
        &quot;Team B&quot;: &quot;Losers&quot;,
    }

    fmt.Println(m)
    delete(m, &quot;Team B&quot;)
    fmt.Println(m)

}
</code></pre>

<p><a href="https://play.golang.org/p/Ece3kpTFKIY">Go Playground</a></p>
<h3 id="maps-cant-contain-duplicate-keys">Maps can't contain duplicate keys</h3>
<pre><code class="go">func main() {

    test := map[string]int{
        &quot;one&quot;:   1,
        &quot;two&quot;:   2,
        &quot;three&quot;: 1,
        &quot;one&quot;:   20, // duplicate
    }

    fmt.Println(test)
}
</code></pre>

<p>The above code will produce this error:</p>
<pre><code>./prog.go:13:3: duplicate key &quot;one&quot; in map literal 
    previous key at ./prog.go:10:3
</code></pre>

<p><a href="https://play.golang.org/p/LbN3tydsGS3">Go Playground</a></p>
<h3 id="incrementing-values">Incrementing values</h3>
<p><strong>Syntax</strong>: <code>map[Key]++</code></p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func main() {
    // list of names
    names := []string{&quot;Willy Denis&quot;, &quot;Billy Markovich&quot;, &quot;John Carpenter&quot;, &quot;Willy Denis&quot;, &quot;Billy Markovich&quot;, &quot;John Carpenter&quot;, &quot;Willy Denis&quot;, &quot;Billy Markovich&quot;,}
    // initialize a map
    votes := make(map[string]int)
    // range over the slice of names
    for _, name := range names { // leave off the index
        votes[name]++ // use the slice's elements as keys and increment its value by one
        // uncomment the following line to see what's happening
        //fmt.Println(votes)
    }
    fmt.Println(&quot;The total number of candidates is&quot;, len(votes))
    fmt.Println()
    for key, value := range votes {
        fmt.Printf(&quot;%v has %v votes.\n&quot;, key, value)
    }
}
</code></pre>

<p><a href="https://play.golang.org/p/9yULbWYAAGr">Go Playground</a></p>
<h3 id="diff-maps-for-duplicate-values">Diff maps for duplicate values</h3>
<p>https://stackoverflow.com/questions/57236845/checking-if-map-has-duplicate-values-in-go</p>
<h3 id="map-as-a-function-argument">Map as a function argument</h3>
<p>If a variable is pointing to an already initialized map....</p>
<p>https://medium.com/wesionary-team/pointers-and-passby-value-reference-in-golang-a00c8c59b7f1</p>
<p>https://www.youtube.com/watch?v=SEd9baxsfEA</p>
<h3 id="copy-a-map">Copy a map</h3>
<p>https://stackoverflow.com/questions/23057785/how-to-copy-a-map</p>
<h2 id="define-your-own-type">Define your own type</h2>
<h2 id="structs">Structs</h2>
<p>A struct is a user defined type. It's constructed by grouping multiple values of a single or multiple types together to form a blueprint.</p>
<h3 id="define-a-struct">Define a struct</h3>
<p>You declare a struct by using the <code>struct keyword</code> as its type. Each field consists of a field name and a field type:</p>
<pre><code class="go">func main() {
    var person struct {
        name     string
        age      int
        employed bool
    }

    person.name = &quot;John&quot;
    person.age = 30
    person.employed = false

    fmt.Println(&quot;My name is&quot;, person.name)
    fmt.Println(&quot;I am&quot;, person.age, &quot;years old&quot;)

    if person.employed {
        fmt.Println(&quot;I am currently&quot;, person.employed)
    }
</code></pre>

<p>To create another person, we would have to define a whole new struct (including all its fields)all over again.</p>
<p><a href="https://play.golang.org/p/TKhulAMvZ6_V">Go Playground</a></p>
<h3 id="define-a-struct-type">Define a struct type</h3>
<p>With a user defined struct, you just need to create a struct type once, and then use it as a blueprint to create an instance of that type.</p>
<p>Syntax: <code>type [StructName] struct{Field FieldType}</code></p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

// struct type of a person
type person struct {
    name     string
    age      int
    employed bool
}

func main() {
    // a struct literal
    john := person{
        name:     &quot;John&quot;,
        age:      30,
        employed: true, // last comma is mandatory
    }

    fmt.Println(john.name)

    var jane person // create another person
    jane.name = &quot;Jane&quot;
    jane.age = 65
    jane.employed = false

    fmt.Println(jane)
}
</code></pre>

<p><a href="https://play.golang.org/p/AKRDRbBVB8s">Go Playground</a></p>
<h3 id="struct-defined-type-as-a-function-parameter">Struct defined type as a function parameter</h3>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

type person struct {
        name     string
        age      int
        employed bool
    }

func getInfo(p person){ // of type person
    fmt.Println(&quot;Name is&quot;, p.name)
    fmt.Println(&quot;Age is&quot;, p.age)
    fmt.Println(&quot;Is employed ?&quot;, p.employed)
}

func main() {

    var john person
    john.name = &quot;John&quot;
    john.age = 30
    john.employed = false

    getInfo(john)
}
</code></pre>

<p><a href="https://play.golang.org/p/66TnxcE50bn">Go Playground</a></p>
<h3 id="try">Try</h3>
<p>https://www.digitalocean.com/community/tutorials/how-to-use-struct-tags-in-go</p>
<h3 id="use-a-pointer-to-modify-a-struct-with-a-function">Use a pointer to modify a struct with a function</h3>
<p>A pointer is needed to modify a struct. Without a pointer, the function will obtain a copy of the struct, and the original data won't be updated.</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

type customer struct {
    name  string
    total int
}

func discount(c *customer) { // take a pointer to a struct 
    c.total = c.total / 2
}

func main() {
    var customer1 customer
    customer1.name = &quot;John&quot;
    customer1.total = 50

    discount(&amp;customer1) // pass a pointer
    fmt.Println(customer1.total)
}
</code></pre>

<p><a href="https://play.golang.org/p/sLkau2D9LW_E">Go Playground</a></p>
<p>https://medium.com/a-journey-with-go/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963</p>
<h3 id="return-a-pointer-to-a-struct">Return a pointer to a struct</h3>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

var(
    pl = fmt.Println
)

type customer struct {
    name         string
    rate         float64
    subscription bool
}

func newCustomer(name string) *customer { //returns a pointer to a struct
    var c customer
    c.name = name
    c.rate = 2.99
    c.subscription = true
    return &amp;c
}

func discount(c *customer) { // takes a pointer
    c.rate = 1.99
    pl(&quot;Discount Applied&quot;)
    pl()
}

func customerInfo(c *customer) { //takes a pointer
    pl(&quot;Name:&quot;, c.name)
    pl(&quot;Monthly Rate:&quot;, c.rate)
    pl(&quot;Active ?&quot;, c.subscription)
}

func main() {
    kavish := newCustomer(&quot;Kavish&quot;) // now the variable kavish is a struct pointer
    customerInfo(kavish)
    pl()
    discount(kavish)
    customerInfo(kavish)    
}
</code></pre>

<p><a href="https://play.golang.org/p/zCJIhYeF_Lj">Go Playground</a></p>
<h3 id="embedding-anonymous-struct-fields">Embedding Anonymous Struct Fields</h3>
<p>There's 3 structure - Employee, Customer, and Address:</p>
<pre><code class="go">package embeddedstructs

type Employee struct {
    Name       string
    Age        int
    Department string
    Salary     float64
    Address
}

type Customer struct {
    Name string
    Age  int
    Rate float64
    Address
}

type Address struct {
    Street     string
    City       string
    State      string
    PostalCode string
}
</code></pre>

<p>The <code>Address</code> field can be accessed as if it's embedded in both <code>Employee</code> and <code>Customer</code>:</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;testing/embeddedstructs&quot; // the file is located in 
)                             // $HOME/go/src/testing/embeddingstructs/embeddingstructs.go

var (
    pl = fmt.Println
) 

func main() {

    customer1 := embeddedstructs.Customer{Name: &quot;Kavish Gour&quot;}
    customer1.Street = &quot;2eme Arrondissement&quot;
    customer1.City = &quot;Paris&quot;
    customer1.State = &quot;France&quot;
    customer1.PostalCode = &quot;75002&quot;

    pl(&quot;Customer Info&quot;)
    pl(&quot;--------------&quot;)
    pl(&quot;Name:&quot;, customer1.Name)
    pl(&quot;Street:&quot;, customer1.Street)
    pl(&quot;City:&quot;, customer1.City)
    pl(&quot;State:&quot;, customer1.State)
    pl(&quot;PostalCode:&quot;, customer1.PostalCode)
    pl()

    employee := embeddedstructs.Employee{Name: &quot;Jean Delatour&quot;}
    employee.Street = &quot;4eme Arrondissement&quot;
    employee.City = &quot;Paris&quot;
    employee.State = &quot;France&quot;
    employee.PostalCode = &quot;75004&quot;

    pl(&quot;Employee Info&quot;)
    pl(&quot;--------------&quot;)
    pl(&quot;Name:&quot;, employee.Name)
    pl(&quot;Street:&quot;, employee.Street)
    pl(&quot;City:&quot;, employee.City)
    pl(&quot;State:&quot;, employee.State)
    pl(&quot;PostalCode:&quot;, employee.PostalCode)
}
</code></pre>

<h3 id="methods">Methods</h3>
<p>https://medium.com/rungo/structures-in-go-76377cc106a2
https://medium.com/rungo/interfaces-in-go-ab1601159b3a
https://medium.com/rungo/anatomy-of-methods-in-go-f552aaa8ac4a</p>
<h3 id="encapsulation">Encapsulation</h3>
<p>https://www.digitalocean.com/community/tutorials/defining-structs-in-go</p>
<p>https://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/</p>
<h2 id="package-visibility">Package Visibility</h2>
<p>https://www.digitalocean.com/community/tutorials/understanding-package-visibility-in-go</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../grep/" class="btn btn-neutral float-right" title="Grep">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../bash_alias/" class="btn btn-neutral" title="Bash Alias"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../bash_alias/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../grep/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
